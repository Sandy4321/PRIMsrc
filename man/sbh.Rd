\name{sbh}

\alias{sbh}

\title{Cross-Validated Fitting of a Survival Bump Hunting Model}

\description{
   Second end-user function for fitting a cross-validated Survival Bump Hunting (SBH) model.
   Returns a cross-validated \code{PRSP} object, as generated by our Patient Recursive Survival Peeling or PRSP algorithm,
   containing cross-validated estimates of end-points statistics of interest.
}

\usage{
  sbh(cvobj = NULL, 
      A = 1000, cpv = FALSE, decimals = 2,
      probval = NULL, timeval = NULL, 
      parallel = FALSE, conf = NULL, seed = NULL)
}

\arguments{
  \item{cvobj}{
    Object of class \code{CV} as generated by the main function \code{\link[PRIMsrc]{cv.sbh}}.
  }
  \item{A}{
    Positive \code{integer} scalar of the number of permutations for the computation of cross-validated p-values. 
    Defaults to 1000.
  }
  \item{cpv}{
    \code{logical} scalar. Flag for computation of permutation p-values. 
    Defaults to \code{FALSE}.
  }
  \item{decimals}{
    \code{integer} scalar. Number of user-specified significant decimals to output results.
    Defaults to 2.
  }
  \item{probval}{
    \code{Numeric} scalar of the survival probability at which we want to get the endpoint box survival time. Defaults to NULL.
  }
  \item{timeval}{
    \code{Numeric} scalar of the survival time at which we want to get the endpoint box survival probability. Defaults to NULL.
  }
  \item{parallel}{
    \code{Logical}. Is parallel computing to be performed? Optional. Defaults to \code{FALSE}.
  }
  \item{conf}{
    \code{List} of parameters for cluster configuration.
    Inputs for R package \pkg{parallel} function \code{makeCluster} (R package \pkg{parallel}) for cluster setup.
    Optional, defaults to \code{NULL}. See details for usage.
  }
  \item{seed}{
    Positive \code{integer} scalar of the user seed to reproduce the results.
 }
}

\details{
  At this point, the main function \code{sbh} performs the search of the \emph{first} box of the recursive coverage (outer) loop of our 
  Patient Recursive Survival Peeling (PRSP) algorithm. It relies on a single internal cross-validation procedure carried out by the main 
  function \code{\link[PRIMsrc]{cv.sbh}} to simultaneously control model size (#covariates) and model complexity (#peeling steps) 
  before the model is fit.
  
  The returned S3-class \code{PRSP} object contains cross-validated estimates of all the decision-rules of pre-selected covariates and 
  all other statistical quantities of interest at each iteration of the peeling sequence (inner loop of the PRSP algorithm). 
  This enables the graphical display of results of peeling trajectories, covariate traces and survival distributions 
  (see plotting functions for more details).

  In case replicated cross-validations are performed (see object \code{CV}), a "summary" of the outputs is done over the number of
  replicates, which requires some explanation:
  \itemize{
    \item Even thought the PRSP algorithm uses only one covariate at a time at each peeling step, the reported matrix of 
    "Replicated CV" box decision rules may show several covariates being used in a given step, simply because these decision rules 
    are averaged over the \eqn{B} replicates (see equation #21 in Dazard et al. 2015). This is also reflected in the reported 
    "Replicated CV" importance and usage plots of covariate traces.
  
    \item Likewise, the output matrix of "Replicated CV" box membership indicator does not necessarily match exactly the output vector 
    of "Replicated CV" box support (and corresponding box sample size) for all peeling steps. The reason is that the reported 
    "Replicated CV" box membership indicators are computed (at each peeling step) as the point-wise majority vote over the \eqn{B} 
    replicates (see equation #22 in Dazard et al. 2015), whereas the "Replicated CV" box support vector (and corresponding box sample size) 
    is averaged (at each peeling step) over the \eqn{B} replicates.
  }

  The function takes advantage of the R package \pkg{parallel}, which allows users to create a cluster of workstations on a local
  and/or remote machine(s), enabling scaling-up with the number of specified CPU cores and efficient parallel execution.
    
  If the computation of permutation \emph{p}-values is desired, then running with the parallelization option is strongly advised 
  as it may take a while. In the case of large (\eqn{p > n}) or very large (\eqn{p >> n}) datasets, it is also required to use the 
  parallelization option. 
  
  To run a parallel session (and parallel RNG) of the PRIMsrc procedures (\code{parallel}=\code{TRUE}), argument \code{conf}
  is to be specified (i.e. non \code{NULL}). It must list the specifications of the folowing parameters for cluster configuration:
  "names", "cpus", "type", "homo", "verbose", "outfile". These match the arguments described in function \code{makeCluster}
  of the R package \pkg{parallel}. All fields are required to properly configure the cluster, except for "names" and "cpus",
  which are the values used alternatively in the case of a cluster of type "SOCK" (socket), or in the case of a cluster
  of type other than "SOCK" (socket), respectively. See examples below.
  \itemize{
        \item "names": \code{names} : \code{character} \code{vector} specifying the host names on which to run the job.
              Could default to a unique local machine, in which case, one may use the unique host name "localhost".
              Each host name can potentially be repeated to the number of CPU cores available on the corresponding machine.
        \item "cpus": \code{spec} : \code{integer} scalar specifying the total number of CPU cores to be used
              across the network of available nodes, counting the workernodes and masternode.
        \item "type": \code{type} : \code{character} \code{vector} specifying the cluster type ("SOCK", "PVM", "MPI").
        \item "homo": \code{homogeneous} : \code{logical} scalar to be set to \code{FALSE} for inhomogeneous clusters.
        \item "verbose": \code{verbose} : \code{logical} scalar to be set to \code{FALSE} for quiet mode.
        \item "outfile": \code{outfile} : \code{character} \code{vector} of the output log file name for the workernodes.
  }
  
  Note that argument \code{A} is internally reset to \code{conf$cpus}*\code{ceiling}(\code{A}/\code{conf$cpus}) in case the 
  parallelization is used (i.e. \code{conf} is non \code{NULL}), where \code{conf$cpus} denotes the total number of CPUs to be 
  used (see above).

  The actual creation of the cluster, its initialization, and closing are all done internally.
  In addition, when random number generation is needed, the creation of separate streams of parallel RNG per node
  is done internally by distributing the stream states to the nodes (For more details see function \code{makeCluster}
  (R package \pkg{parallel}) and/or \url{http://www.stat.uiowa.edu/~luke/R/cluster/cluster.html}.
  
  The use of a seed allows to reproduce the results within the same type of session: the same seed will reproduce the same results 
  within a non-parallel session or within a parallel session, but it will not necessarily give the exact same results (up to sampling variability)
  between a non-parallelized and parallelized session due to the difference of management of the seed between the two (see parallel RNG and 
  value of retuned seed below).
}

\value{
  Object of \code{class} \code{PRSP} (Patient Recursive Survival Peeling)
  \code{List} containing the following 19 fields:
    \item{x}{\code{numeric} \code{matrix} of original dataset.}
    \item{times}{\code{numeric} \code{vector} of observed failure / survival times.}
    \item{status}{\code{numeric} \code{vector} of observed event indicator in \{1,0\}.}
    \item{B}{positive \code{integer} of the number of replications used in the cross-validation procedure.}
    \item{K}{positive \code{integer} of the number of folds used in the cross-validation procedure.}
    \item{A}{positive \code{integer} of the number of permutations used for the computation of permutation p-values.}
    \item{cpv}{\code{logical} scalar of returned flag of optional computation of permutation p-values.}
    \item{decimals}{\code{integer} of the number of user-specified significant decimals.}
    \item{cvtype}{\code{character} \code{vector} of the cross-validation technique used.}
    \item{cvcriterion}{\code{character} \code{vector} of optimization criterion used.}
    \item{conservative}{\code{character} \code{vector} degree of conservativeness used.}
    \item{arg}{\code{character} \code{vector} of the parameters used.}
    \item{probval}{\code{Numeric} scalar of survival probability used.}
    \item{timeval}{\code{Numeric} scalar of survival time used.}
    \item{cvfit}{\code{List} with 9 fields of cross-validated estimates:
        \itemize{
            \item{cv.maxsteps}: \code{numeric} scalar of maximal number of peeling steps over the replicates.
            \item{cv.nsteps}: \code{numeric} scalar of optimal number of peeling steps according to the optimization criterion.
            \item{cv.trace}: \code{numeric} \code{vector} of the modal trace values of covariate usage for all peeling steps.
            \item{cv.sel}{\code{numeric} \code{vector} of pre-selected covariates in reference to original index.}
            \item{cv.sign}{\code{numeric} \code{vector} in \{-1,+1\} of directions of peeling for all pre-selected covariates.} 
            \item{cv.boxind}: \code{logical} \code{matrix} in {\code{TRUE}, \code{FALSE}} of individual observation box membership indicator (columns) for all peeling steps (rows).
            \item{cv.rules}: \code{data.frame} of decision rules on the covariates (columns) for all peeling steps (rows).
            \item{cv.stats}: \code{numeric} \code{matrix} of box endpoint quantities of interest (columns) for all peeling steps (rows).
            \item{cv.pval}: \code{numeric} \code{vector} of log-rank permutation p-values of sepraration of survival distributions.}
        }
    \item{plot}{\code{logical} scalar of the returned flag for plotting or not the results of the fitted SBH model.}
    \item{config}{\code{List} with 7 fields of parameters used for configuring the parallelization including \code{parallel} and \code{conf}.}
    \item{seed}{User seed(s) used:
        \code{integer} of a single value, if parallelization is used
        \code{integer} \code{vector} of values, one for each replication, if parallelization is not used.}
}

\references{
    \itemize{
        \item Dazard J-E., Choe M., LeBlanc M. and Rao J.S. (2015).
              "\emph{Cross-validation and Peeling Strategies for Survival Bump Hunting using Recursive Peeling Methods.}"
              Statistical Analysis and Data Mining (in press).
        \item Dazard J-E., Choe M., LeBlanc M. and Rao J.S. (2014).
              "\emph{Cross-Validation of Survival Bump Hunting by Recursive Peeling Methods.}"
              In JSM Proceedings, Survival Methods for Risk Estimation/Prediction Section. Boston, MA, USA.
              American Statistical Association IMS - JSM, p. 3366-3380.
        \item Dazard J-E., Choe M., LeBlanc M. and Rao J.S. (2015).
              "\emph{R package PRIMsrc: Bump Hunting by Patient Rule Induction Method for Survival, Regression and Classification.}"
              In JSM Proceedings, Statistical Programmers and Analysts Section. Seattle, WA, USA.
              American Statistical Association IMS - JSM, (in press).
        \item Dazard J-E. and J.S. Rao (2010).
              "\emph{Local Sparse Bump Hunting.}"
              J. Comp Graph. Statistics, 19(4):900-92.
    }
}

\author{
    \itemize{
        \item "Jean-Eudes Dazard, Ph.D." \email{jxd101@case.edu}
        \item "Michael Choe, M.D." \email{mjc206@case.edu}
        \item "Michael LeBlanc, Ph.D." \email{mleblanc@fhcrc.org}
        \item "Alberto Santana, MBA." \email{ahs4@case.edu}
    }
    Maintainer: "Jean-Eudes Dazard, Ph.D." \email{jxd101@case.edu}

    Acknowledgments: This project was partially funded by the National Institutes of Health
    NIH - National Cancer Institute (R01-CA160593) to J-E. Dazard and J.S. Rao.
}

\note{
    Unique end-user function for fitting the Survival Bump Hunting model.
}

\keyword{Exploratory Survival/Risk Analysis}
\keyword{Survival/Risk Estimation & Prediction}
\keyword{Non-Parametric Method}
\keyword{Cross-Validation}
\keyword{Bump Hunting}
\keyword{Rule-Induction Method}


\seealso{
    \itemize{
        \item \code{makeCluster} (R package \pkg{parallel})
        \item \code{cv.glmnet} (R package \pkg{glmnet})
        \item \code{glmnet} (R package \pkg{glmnet})
    }
}

\examples{
#===================================================
# Loading the library and its dependencies
#===================================================
library("PRIMsrc")

#===================================================
# Package news
# Package citation
#===================================================
PRIMsrc.news()
citation("PRIMsrc")

#===================================================
# Demo with a synthetic dataset
# Use help for descriptions
#===================================================
data("Synthetic.1", package="PRIMsrc")
?Synthetic.1

#===================================================
# Simulated dataset #1 (n=250, p=3)
# Non Replicated Combined Cross-Validation (RCCV)
# Peeling criterion = LRT
# Optimization criterion = LRT
# Without parallelization
# Without computation of permutation p-values
#===================================================
CVCOMB.CV <- cv.sbh(dataset = Synthetic.1,
                    B = 1, K = 5,
                    cvtype = "combined",
                    cvcriterion = "lrt",
                    conservative = "least",
                    arg = "beta=0.05,
                           alpha=0.05,
                           minn=5,
                           peelcriterion=\"lr\"",
                    fdr = NULL, thr = NULL,
                    parallel = FALSE, conf = NULL, seed = 123)

CVCOMB.SBH <- sbh(cvobj = CVCOMB.CV,
                  cpv = FALSE, decimals = 2,
                  probval = 0.5, timeval = NULL,
                  parallel = FALSE, conf = NULL, seed = 123)

\dontrun{
    #===================================================
    # Examples of parallel backend parametrization 
    #===================================================
    # Example #1 - 1-Quad (4-core double threaded) PC 
    # Running WINDOWS
    # With SOCKET communication
    #===================================================
    if (.Platform$OS.type == "windows") {
        cpus <- detectCores()
        conf <- list("names" = rep("localhost", cpus),
                     "cpus" = cpus,
                     "type" = "SOCK",
                     "homo" = TRUE,
                     "verbose" = TRUE,
                     "outfile" = "")
    }
    #===================================================
    # Example #2 - 1 master node + 3 worker nodes cluster
    # All nodes equipped with identical setups and multicores
    # Running LINUX
    # With SOCKET communication
    #===================================================
    if (.Platform$OS.type == "unix") {
        masterhost <- Sys.getenv("HOSTNAME")
        slavehosts <- c("compute-0-0", "compute-0-1", "compute-0-2")
        nodes <- length(slavehosts) + 1
        cpus <- 8
        conf <- list("names" = c(rep(masterhost, cpus),
                                 rep(slavehosts, cpus)),
                     "cpus" = nodes * cpus,
                     "type" = "SOCK",
                     "homo" = TRUE,
                     "verbose" = TRUE,
                     "outfile" = "")
    }
    #===================================================
    # Example #3 - Multinode multicore per node cluster
    # Running LINUX 
    # with MPI communication
    # Here, a file named ".nodes" (e.g. in the home directory)
    # contains the list of nodes of the cluster
    #===================================================
    if (.Platform$OS.type == "unix") {
        hosts <- scan(file=paste(Sys.getenv("HOME"), "/.nodes", sep=""), 
                      what="", 
                      sep="\n")
        hostnames <- unique(hosts)
        nodes <- length(hostnames)
        cpus <-  length(hosts)/length(hostnames)
        conf <- list("cpus" = nodes * cpus,
                     "type" = "MPI",
                     "homo" = TRUE,
                     "verbose" = TRUE,
                     "outfile" = "")
    }
    #===================================================
    # Simulated dataset #1 (n=250, p=3)
    # Replicated Combined Cross-Validation (RCCV)
    # Peeling criterion = LRT
    # Optimization criterion = LRT
    # With parallelization
    # With computation of permutation p-values
    #===================================================
    CVCOMBREP.CV <- cv.sbh(dataset = Synthetic.1,
                           B = 10, K = 5,
                           cvtype = "combined",
                           cvcriterion = "lrt",
                           conservative = "least",
                           arg = "beta=0.05,
                                  alpha=0.05,
                                  minn=5,
                                  peelcriterion=\"lr\"",
                           fdr = NULL, thr = NULL,
                           parallel = TRUE, conf = conf, seed = 123)

    CVCOMBREP.SBH <- sbh(cvobj = CVCOMBREP.CV, 
                         A = 1000, cpv = TRUE, decimals = 2, 
                         probval = 0.5, timeval = NULL,
                         parallel = TRUE, conf = conf, seed = 123)
}
}
