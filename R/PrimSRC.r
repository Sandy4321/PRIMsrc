##########################################################################################################################################
# PrimSRC
##########################################################################################################################################

##########################################################################################################################################
# 1. SURVIVAL MAIN FUNCTION
##########################################################################################################################################

##########################################################################################################################################
#################
#Usage         :
################
#                   sbh(dataset, discr,
#                       B=10, K=5, A=1000, cpv=FALSE, cvtype="combined", cvcriterion="lrt",
#                       arg="beta=0.05,alpha=0.1,minn=10,L=NULL,peelcriterion=\"lr\"",
#                       probval=NULL, timeval=NULL,
#                       parallel=FALSE, conf=NULL, seed=NULL)
#
################
# Description   :
################
#                   Main and unique end-user function for fitting a cross-validated survival bump hunting model.
#                   Returns cross-validated "PRSP" object, as generated by our Patient Recursive Survival Peeling or PRSP algorithm
#                   at each iteration of the peeling sequence (inner loop of the PRSP algorithm).
#
################
# Arguments     :
################
# dataset       :   Data.frame or numeric matrix of input dataset containing the observed survival and status indicator variables in the first two columns, respectively.
# discr         :   Logical vector describing what covariates are discrete. Defaults to logical(ncol(dataset)-2).
# B             :   Number of replications of the cross-validation procedure. Defaults to 10.
# K             :   Number of folds for the cross-validation procedure. Defaults to 5.
# A             :   Number of permutations for the computation of p-values. Defaults to 1000.
# cpv           :   Logical. Flag for computation of cross-validated p-values. Defaults to FALSE.
#                   If computation of cross-validated p-value is deired, then running with the parallelization option is
#                   strongly advised, as it may take a while otherwise.
# cvtype        :   Character vector describing the cross-validation technique in {"none", "averaged", "combined"}.
#                   Defaults to "combined".
# cvcriterion   :   Character vector describing the cross-validation optimization criterion in {"lhr", "lrt", "cer"}.
#                   Defaults to "lrt". Automatically set to NULL if cvtype="none".
# arg           :   Character vector describing the parameters to use:
#                     alpha = fraction to peel off at each step. Defaults to 0.1.
#                     beta = minimum support size resulting from the peeling sequence. Defaults to 0.05.
#                     minn = minimum number of observation in a box. Defaults to 10.
#                     L = fixed peeling length. Defaults to NULL.
#                     peelcriterion in {"hr", "lr"}. Defaults to "lr".
# probval       :   Survival probability at which we want to get the endpoint box survival time.
#                   Defaults to NULL.
# timeval       :   Survival time at which we want to get the endpoint box survival probability.
#                   Defaults to NULL.
# parallel      :   Logical. Is parallel computing to be performed? Optional, defaults to FALSE.
# conf          :   List of parameters for cluster configuration.
#                   Inputs for R package parallel function makeCluster() for cluster setup.
#                   Optional, defaults to NULL. See details for usage.
# seed          :   User seed to reproduce the results.
#
################
# Values        :
################
#               :   Object of class "PRSP" (Patient Recursive Survival Peeling), list containing the following fields:
#
# x             :   Numeric matrix of original covariates.
# times         :   Observed failure / survival times.
# status        :   Observed event indicator \in {1,0}.
# B             :   Number of replications used in the cross-validation procedure.
# K             :   Number of folds used for the cross-validation procedure.
# A             :   Number of permutations used for the computation of p-values.
# cpv           :   Returned flag of computation of cross-validated p-values.
# cvtype        :   Cross-validation technique used.
# cvcriterion   :   Cross-validation optimization criterion used.
# varsign       :   Numeric vector \in {-1,+1} of directions of peeling for all variables.
# selected        :   Numeric vector giving the selected variable by regularized (Elastic-Net) Cox-regression.
# arg           :   Character vector of parameters used.
# probval       :   Survival probability used.
# timeval       :   Survival time used.
# cvfit         :   List of 9 fiels of cross-validated estimates:
#                     "cv.maxsteps"=numeric scalar of maximal ceiled-mean of number of peeling steps over the replicates
#                     "cv.nsteps"=numeric scalar of optimal number of peeling steps according to the optimization criterion
#                     "cv.trace"=list of numeric matrix and numeric vector of variable usage traces or modal trace values at each step
#                     "cv.boxind"=logical matrix {TRUE, FALSE} of sample box membership indicator (columns) by peeling steps (rows)
#                     "cv.vertices"=numeric matrix of box vertices. LB=Lower Bound and UB=Upper Bound by rows. Dimensions by columns
#                     "cv.rules"=data.frame of decision rules on the variable (columns) by peeling steps (rows)
#                     "cv.stats"=numeric matrix of box quantities of interest (columns) by peeling steps (rows)
#                     "cv.pval"=numeric vector of cross-validated log-rank p-values of sepraration of survival distributions
# cvprofiles    :   List (B) of numeric vectors, one for each replicate, of cross-validated statistic
#                   used in the optimization criterion (setup by user)
#                   as  function of the number of peeling steps.
# plot          :   Returned flag for plotting results (TRUE if cross-validation successful)
# seed          :   User seed(s) used:
#                   Integer scalar of a single value, if parallelization is used.
#                   Integer vector of values, one for each replication, if parallelization is not used.
#
##########################################################################################################################################

sbh <- function(dataset, discr,
                B=10, K=5, A=1000, cpv=FALSE, cvtype="combined", cvcriterion="lrt",
                arg="beta=0.05,alpha=0.1,minn=10,L=NULL,peelcriterion=\"lr\"",
                probval=NULL, timeval=NULL,
                parallel=FALSE, conf=NULL, seed=NULL) {

  # Parsing and evaluating parameters
  alpha <- NULL
  beta <- NULL
  minn <- NULL
  L <- NULL
  peelcriterion <- NULL
  eval(parse( text=unlist(strsplit(x=arg, split=",")) ))
  digits <- getOption("digits")

  # Checks
  if (missing(dataset)) {
    stop("\nNo dataset provided !\n\n")
  } else {
    cat("\nSurvival dataset provided.\n\n")
    if (!(is.data.frame(dataset)))
      dataset <- as.data.frame(dataset)
    x <- as.matrix(dataset[ ,-c(1,2), drop=FALSE])
    times <- dataset$stime
    status <- dataset$status
    times[times <= 0] <- 10^(-digits)
    n <- nrow(x)
    p <- ncol(x)
    if (missing(discr))
      discr <- logical(p)
  }

  # Summary of user options
  if (cvtype != "none") {
    if (B > 1) {
      cat("Requested replicated ", K, "-fold cross-validation with ", B, " replications \n", sep="")
    } else {
      cat("Requested single ", K, "-fold cross-validation with no replications \n", sep="")
    }
    cat("Cross-validation technique: ", cvtype, "\n")
    cat("Cross-validation criterion: ", cvcriterion, "\n")
    cat("Cross-validated p-values:", cpv, "\n")
  } else {
    cat("No cross-validation requested \n")
  }
  cat("Peeling criterion: ", peelcriterion, "\n")
  cat("Parallelization:", parallel, "\n")
  cat("\n")

  # Variable selection by regularized Cox-regression
  cat("Variable selection by regularized Cox-regression ... \n")
  set.seed(seed)
  continue <- "y"
  while (continue == "y") {
    cv.fit <- cv.glmnet(x=x, y=Surv(times, status), nfolds=max(3,K), family="cox", maxit=1e5)
    fit <- glmnet(x=x, y=Surv(times, status), family="cox", maxit=1e5)
    cv.coef <- as.numeric(coef(fit, s = cv.fit$lambda.min))
    selected <- which(cv.coef != 0)
    names(selected) <- colnames(x)[selected]
    cat("Selected variables:\n")
    print(selected)
    if (is.empty(selected)) {
      continue <- readline(prompt = "No selected variables!. Try again with a new random seed? yes(\"y\"), no(\"n\").")
      while (!(continue %in% c("y", "n"))) {
        continue <- readline(prompt = "Wrong answer! Try again? yes(\"y\"), no(\"n\").")
      }
      set.seed(runif(n=1, min=1, max=2) * 10^digits)
      if (continue == "n") {
        stop("Process ended by user.\n")
      }
    } else {
      continue <- "n"
    }
  }

  # Directions of directed peeling by selected variable and initial box boundaries
  varsign <- sign(cv.coef)
  names(varsign) <- colnames(x)

  initcutpts <- numeric(p)
  for(j in 1:p){
    if ((varsign[j] == 0) || (varsign[j] == 1)) {
      initcutpts[j] <- min(x[,j])
    } else if (varsign[j] == -1) {
      initcutpts[j] <- max(x[,j])
    } else {
      stop("Erreur in direction of peeling for variable", j, "\n")
    }
  }

  if (cvtype == "none") {
    cvcriterion <- NULL
  }

  cat("Fitting and cross-validating the Survival Bump Hunting model using the PRSP algorithm ... \n")
  if (!parallel) {
    if (is.null(seed)) {
      seed <- runif(n=B, min=1, max=2) * 10^digits
    } else {
      seed <- (0:(B-1)) + seed
    }
    CV.box.rep.obj <- cv.box.rep(x=x, times=times, status=status,
                                 B=B, K=K, arg=arg,
                                 cvtype=cvtype,
                                 probval=probval, timeval=timeval,
                                 varsign=varsign, selected=selected, initcutpts=initcutpts,
                                 parallel=parallel, seed=seed)
  } else {
    if (conf$type == "SOCK") {
      cl <- makeCluster(spec=conf$names,
                        type=conf$type,
                        homogeneous=conf$homo,
                        outfile=conf$outfile,
                        verbose=conf$verbose)
    } else {
      cl <- makeCluster(spec=conf$cpus,
                        type=conf$type,
                        homogeneous=conf$homo,
                        outfile=conf$outfile,
                        verbose=conf$verbose)
    }
    clusterSetRNGStream(cl=cl, iseed=seed)
    a <- ceiling(B/conf$cpus)
    obj.cl <- clusterCall(cl=cl, fun=cv.box.rep,
                          x=x, times=times, status=status,
                          B=a, K=K, arg=arg,
                          cvtype=cvtype,
                          probval=probval, timeval=timeval,
                          varsign=varsign, selected=selected, initcutpts=initcutpts,
                          parallel=parallel, seed=NULL)
    stopCluster(cl)
    CV.box.rep.obj <- list("cv.maxsteps"=numeric(0),
                           "cv.nsteps.lhr"=numeric(0),
                           "cv.nsteps.lrt"=numeric(0),
                           "cv.nsteps.cer"=numeric(0),
                           "cv.trace"=vector(mode="list", length=B),
                           "cv.boxind"=vector(mode="list", length=B),
                           "cv.boxcut"=vector(mode="list", length=B),
                           "cv.vertices"=vector(mode="list", length=B),
                           "cv.support"=vector(mode="list", length=B),
                           "cv.lhr"=vector(mode="list", length=B),
                           "cv.lrt"=vector(mode="list", length=B),
                           "cv.cer"=vector(mode="list", length=B),
                           "cv.time.bar"=vector(mode="list", length=B),
                           "cv.prob.bar"=vector(mode="list", length=B),
                           "cv.max.time.bar"=vector(mode="list", length=B),
                           "cv.min.prob.bar"=vector(mode="list", length=B))
    for (b in 1:min(B,conf$cpus)) {
      CV.box.rep.obj$cv.maxsteps <- c(CV.box.rep.obj$cv.maxsteps, obj.cl[[b]]$cv.maxsteps)
      CV.box.rep.obj$cv.nsteps.lhr <- c(CV.box.rep.obj$cv.nsteps.lhr, obj.cl[[b]]$cv.nsteps.lhr)
      CV.box.rep.obj$cv.nsteps.lrt <- c(CV.box.rep.obj$cv.nsteps.lrt, obj.cl[[b]]$cv.nsteps.lrt)
      CV.box.rep.obj$cv.nsteps.cer <- c(CV.box.rep.obj$cv.nsteps.cer, obj.cl[[b]]$cv.nsteps.cer)
      CV.box.rep.obj$cv.trace[((b-1)*a+1):(b*a)] <- obj.cl[[b]]$cv.trace
      CV.box.rep.obj$cv.boxind[((b-1)*a+1):(b*a)] <- obj.cl[[b]]$cv.boxind
      CV.box.rep.obj$cv.boxcut[((b-1)*a+1):(b*a)] <- obj.cl[[b]]$cv.boxcut
      CV.box.rep.obj$cv.vertices[((b-1)*a+1):(b*a)] <- obj.cl[[b]]$cv.vertices
      CV.box.rep.obj$cv.support[((b-1)*a+1):(b*a)] <- obj.cl[[b]]$cv.support
      CV.box.rep.obj$cv.lhr[((b-1)*a+1):(b*a)] <- obj.cl[[b]]$cv.lhr
      CV.box.rep.obj$cv.lrt[((b-1)*a+1):(b*a)] <- obj.cl[[b]]$cv.lrt
      CV.box.rep.obj$cv.cer[((b-1)*a+1):(b*a)] <- obj.cl[[b]]$cv.cer
      CV.box.rep.obj$cv.time.bar[((b-1)*a+1):(b*a)] <- obj.cl[[b]]$cv.time.bar
      CV.box.rep.obj$cv.prob.bar[((b-1)*a+1):(b*a)] <- obj.cl[[b]]$cv.prob.bar
      CV.box.rep.obj$cv.max.time.bar[((b-1)*a+1):(b*a)] <- obj.cl[[b]]$cv.max.time.bar
      CV.box.rep.obj$cv.min.prob.bar[((b-1)*a+1):(b*a)] <- obj.cl[[b]]$cv.min.prob.bar
    }
    CV.box.rep.obj$success <- obj.cl[[1]]$success
  }

  # Collect the peeling statistics for each step from all the replicates
  CV.maxsteps <- CV.box.rep.obj$cv.maxsteps
  CV.nsteps.lhr <- CV.box.rep.obj$cv.nsteps.lhr
  CV.nsteps.lrt <- CV.box.rep.obj$cv.nsteps.lrt
  CV.nsteps.cer <- CV.box.rep.obj$cv.nsteps.cer
  CV.trace <- CV.box.rep.obj$cv.trace
  CV.boxind <- CV.box.rep.obj$cv.boxind
  CV.boxcut <- CV.box.rep.obj$cv.boxcut
  CV.vertices <- CV.box.rep.obj$cv.vertices
  CV.support <- CV.box.rep.obj$cv.support
  CV.lhr <- CV.box.rep.obj$cv.lhr
  CV.lrt <- CV.box.rep.obj$cv.lrt
  CV.cer <- CV.box.rep.obj$cv.cer
  CV.time.bar <- CV.box.rep.obj$cv.time.bar
  CV.prob.bar <- CV.box.rep.obj$cv.prob.bar
  CV.max.time.bar <- CV.box.rep.obj$cv.max.time.bar
  CV.min.prob.bar <- CV.box.rep.obj$cv.min.prob.bar
  success <- CV.box.rep.obj$success

  if (!success) {

    cat("Failure! Could not find any bump in this dataset after running ", B ," replications\n", sep="")
    bool.plot <- FALSE

    # Cross-validated minimum length from all replicates
    CV.maxsteps <- NULL

    # List of CV profiles
    CV.profiles <- NULL

    # Cross-validated optimal length from all replicates
    CV.nsteps <- NULL

    # Modal or majority vote trace value over the replicates
    CV.trace <- NULL

    # List of box boxcut and box peeling rules for each step
    CV.rules <- NULL

    # Box membership indicator vector of all observations for each step
    CV.boxind <- NULL

    # List of box vertices for each step
    CV.vertices <- NULL

    # List of box statistics for each step
    CV.stats <- NULL

    # List of p-values for each step
    CV.pval <- NULL

  } else {

    cat("Success! ", B, " (replicated) cross-validation(s) has(ve) completed \n", sep="")
    bool.plot <- TRUE

    # Cross-validated minimum length from all replicates
    CV.maxsteps <- ceiling(mean(CV.maxsteps))

    # List of CV profiles
    cat("Generating cross-validated profiles and optimal peeling length ...\n")
    if ((cvtype == "averaged") || (cvtype == "combined")) {
      CV.lhr.mat <- list2mat(list=CV.lhr, fill=0, trunc=CV.maxsteps)
      CV.lrt.mat <- list2mat(list=CV.lrt, fill=0, trunc=CV.maxsteps)
      CV.cer.mat <- list2mat(list=CV.cer, fill=1, trunc=CV.maxsteps)
    } else if (cvtype == "none") {
      CV.lhr.mat <- matrix(data=NA, nrow=B, ncol=CV.maxsteps)
      CV.lrt.mat <- matrix(data=NA, nrow=B, ncol=CV.maxsteps)
      CV.cer.mat <- matrix(data=NA, nrow=B, ncol=CV.maxsteps)
    } else {
      stop("Invalid CV type option \n")
    }
    CV.profiles <- list("lhr"=CV.lhr.mat, "lrt"=CV.lrt.mat, "cer"=CV.cer.mat)
    colnames(CV.profiles$lhr) <- paste("step", 0:(CV.maxsteps-1), sep="")
    colnames(CV.profiles$lrt) <- paste("step", 0:(CV.maxsteps-1), sep="")
    colnames(CV.profiles$cer) <- paste("step", 0:(CV.maxsteps-1), sep="")

    # List of CV mean profiles
    CV.mean.lhr <- apply(CV.profiles$lhr, 2, mean)
    CV.mean.lrt <- apply(CV.profiles$lrt, 2, mean)
    CV.mean.cer <- apply(CV.profiles$cer, 2, mean)
    CV.mean.profiles <- list("lhr"=CV.mean.lhr, "lrt"=CV.mean.lrt, "cer"=CV.mean.cer)

    # Cross-validated optimal peeling length from all replicates
    if (cvtype == "none") {
      CV.nsteps <- CV.maxsteps
    } else if ((cvtype == "averaged") || (cvtype == "combined")) {
      if (cvcriterion=="lhr") {
        CV.nsteps <- which.max(CV.mean.profiles$lhr)
      } else if (cvcriterion=="lrt") {
        CV.nsteps <- which.max(CV.mean.profiles$lrt)
      } else if (cvcriterion=="cer") {
        CV.nsteps <- which.min(CV.mean.profiles$cer)
      }
    } else {
      stop("Invalid CV type option \n")
    }

    # Variable traces for each step:
    # Distribution of trace values over the replicates, or
    # Modal or majority vote trace value over the loops and replicates
    cat("Generating cross-validated variable traces ...\n")
    trace.dist <- lapply.array(X=CV.trace,
                               trunc=CV.nsteps,
                               FUN=function(x){if (anyNA(x))
                                              return(NA)
                                             else
                                              return(as.numeric(names(which.max(table(x)))))
                                             },
                             MARGIN=c(1,3))
    dimnames(trace.dist) <- list(paste("step", 0:(CV.nsteps-1), sep=""), 1:B)
    trace.mode <- apply(X=trace.dist,
                        FUN=function(x){if (anyNA(x))
                                         return(NA)
                                       else
                                         return(as.numeric(names(which.max(table(x)))))
                                       },
                        MARGIN=1)
    names(trace.mode) <- paste("step", 0:(CV.nsteps-1), sep="")
    CV.trace <- list("dist"=trace.dist, "mode"=trace.mode)

    # Variables used for peeling
    used <- sort(unique(as.numeric(CV.trace$dist[-1,,drop=FALSE])))
    names(used) <- colnames(x)[used]
    cat("Used variables for peeling:\n")
    print(used)

    # List of box peeling rules for each step
    cat("Generating cross-validated box peeling rules for each step ...\n")
    CV.boxcut.mu <- lapply.array(X=CV.boxcut, trunc=CV.nsteps, FUN=function(x){mean(x, na.rm=TRUE)}, MARGIN=1:2)
    if (any(as.logical(discr))) {
      CV.boxcut.mu[,which(as.logical(discr))] <- myround(CV.boxcut.mu[,which(as.logical(discr)),drop=FALSE], 0)
    }
    CV.boxcut.sd <- lapply.array(X=CV.boxcut, trunc=CV.nsteps, FUN=function(x){sd(x, na.rm=TRUE)}, MARGIN=1:2)
    rownames(CV.boxcut.mu) <- paste("step", 0:(CV.nsteps-1), sep="")
    rownames(CV.boxcut.sd) <- paste("step", 0:(CV.nsteps-1), sep="")
    colnames(CV.boxcut.mu) <- colnames(x)
    colnames(CV.boxcut.sd) <- colnames(x)
    CV.tmp <- as.data.frame(matrix(data=NA, nrow=CV.nsteps, ncol=p, dimnames=list(paste("step", 0:(CV.nsteps-1), sep=""), colnames(x))))
    for (j in 1:p) {
      if (varsign[j] > 0) {
        ss <- ">="
      } else {
        ss <- "<="
      }
      CV.tmp[, j] <- paste(paste(colnames(x)[j], ss, format(x=CV.boxcut.mu[, j], digits=3, nsmall=3), sep=""),
                           format(x=CV.boxcut.sd[, j], digits=3, nsmall=3), sep=" +/- ")
    }
    CV.rules <- list("mean"=CV.boxcut.mu, "sd"=CV.boxcut.sd, "frame"=CV.tmp)

    # Box membership indicator vector of all observations for each step
    # (using the modal or majority vote value over the replicates)
    cat("Generating cross-validated box memberships for each step ...\n")
    CV.boxind <- lapply.array(X=CV.boxind, trunc=CV.nsteps, FUN=function(x){mean(x, na.rm=TRUE) >= 0.5}, MARGIN=1:2)
    rownames(CV.boxind) <- paste("step", 0:(CV.nsteps-1), sep="")
    colnames(CV.boxind) <- rownames(x)
    # (using the averaged box over the replicates)
    # CV.boxind <- matrix(NA, nrow=CV.nsteps, ncol=n)
    # for (l in 1:CV.nsteps) {
    #    boxcut <- CV.boxcut.mu[l, ] * varsign
    #    x.cut <- t(t(x) * varsign)
    #    x.ind <- t(t(x.cut) >= boxcut)
    #    CV.boxind[l,] <- (rowMeans(x.ind) == 1)  # Set as TRUE which observations are inside the box boudaries for all axes directions
    # }
    # rownames(CV.boxind) <- paste("step", 0:(CV.nsteps-1), sep="")
    # colnames(CV.boxind) <- rownames(x)

    # List of box statistics for each step
    cat("Generating cross-validated box statistics for each step ...\n")
    CV.support.mu <- lapply.mat(X=CV.support, FUN=function(x){mean(x, na.rm=TRUE)}, trunc=CV.nsteps)
    CV.support.sd <- lapply.mat(X=CV.support, FUN=function(x){sd(x, na.rm=TRUE)}, trunc=CV.nsteps)
    CV.lhr.mu <- lapply.mat(X=CV.lhr, FUN=function(x){mean(x, na.rm=TRUE)}, trunc=CV.nsteps)
    CV.lhr.sd <- lapply.mat(X=CV.lhr, FUN=function(x){sd(x, na.rm=TRUE)}, trunc=CV.nsteps)
    CV.lrt.mu <- lapply.mat(X=CV.lrt, FUN=function(x){mean(x, na.rm=TRUE)}, trunc=CV.nsteps)
    CV.lrt.sd <- lapply.mat(X=CV.lrt, FUN=function(x){sd(x, na.rm=TRUE)}, trunc=CV.nsteps)
    CV.cer.mu <- lapply.mat(X=CV.cer, FUN=function(x){mean(x, na.rm=TRUE)}, trunc=CV.nsteps)
    CV.cer.sd <- lapply.mat(X=CV.cer, FUN=function(x){sd(x, na.rm=TRUE)}, trunc=CV.nsteps)
    CV.time.bar.mu <- lapply.mat(X=CV.time.bar, FUN=function(x){mean(x, na.rm=TRUE)}, trunc=CV.nsteps)
    CV.time.bar.sd <- lapply.mat(X=CV.time.bar, FUN=function(x){sd(x, na.rm=TRUE)}, trunc=CV.nsteps)
    CV.prob.bar.mu <- lapply.mat(X=CV.prob.bar, FUN=function(x){mean(x, na.rm=TRUE)}, trunc=CV.nsteps)
    CV.prob.bar.sd <- lapply.mat(X=CV.prob.bar, FUN=function(x){sd(x, na.rm=TRUE)}, trunc=CV.nsteps)
    CV.max.time.bar.mu <- lapply.mat(X=CV.max.time.bar, FUN=function(x){mean(x, na.rm=TRUE)}, trunc=CV.nsteps)
    CV.max.time.bar.sd <- lapply.mat(X=CV.max.time.bar, FUN=function(x){sd(x, na.rm=TRUE)}, trunc=CV.nsteps)
    CV.min.prob.bar.mu <- lapply.mat(X=CV.min.prob.bar, FUN=function(x){mean(x, na.rm=TRUE)}, trunc=CV.nsteps)
    CV.min.prob.bar.sd <- lapply.mat(X=CV.min.prob.bar, FUN=function(x){sd(x, na.rm=TRUE)}, trunc=CV.nsteps)
    CV.stats.mu <- data.frame("cv.support"=CV.support.mu,
                              "cv.lhr"=CV.lhr.mu,
                              "cv.lrt"=CV.lrt.mu,
                              "cv.cer"=CV.cer.mu,
                              "cv.time.bar"=CV.time.bar.mu,
                              "cv.prob.bar"=CV.prob.bar.mu,
                              "cv.max.time.bar"=CV.max.time.bar.mu,
                              "cv.min.prob.bar"=CV.min.prob.bar.mu)
    rownames(CV.stats.mu) <- paste("step", 0:(CV.nsteps-1), sep="")
    CV.stats.sd <- data.frame("cv.support"=CV.support.sd,
                              "cv.lhr"=CV.lhr.sd,
                              "cv.lrt"=CV.lrt.sd,
                              "cv.cer"=CV.cer.sd,
                              "cv.time.bar"=CV.time.bar.sd,
                              "cv.prob.bar"=CV.prob.bar.sd,
                              "cv.max.time.bar"=CV.max.time.bar.sd,
                              "cv.min.prob.bar"=CV.min.prob.bar.sd)
    rownames(CV.stats.sd) <- paste("step", 0:(CV.nsteps-1), sep="")
    CV.stats <- list("mean"=CV.stats.mu, "sd"=CV.stats.sd)

    # Vector of p-values for each step
    if ((cpv) && (cvtype != "none")) {
      cat("Computation of cross-validated LRT p-values at all steps ... \n")
      arg <- paste("beta=", beta, ",alpha=", alpha, ",minn=", minn, ",L=", CV.nsteps-1, ",peelcriterion=\"", peelcriterion, "\"", sep="")
      CV.pval <- cv.pval(x=x, times=times, status=status,
                         cvtype=cvtype,
                         varsign=varsign, selected=selected, initcutpts=initcutpts,
                         A=A, K=K, arg=arg, obs.chisq=CV.stats$mean$cv.lrt,
                         parallel=parallel, conf=conf)
    } else {
      CV.pval <- NULL
    }
  }

  # Create the return object 'CV.fit'
  CV.fit <- list("cv.maxsteps"=CV.maxsteps,
                 "cv.nsteps"=CV.nsteps,
                 "cv.trace"=CV.trace,
                 "cv.boxind"=CV.boxind,
                 "cv.rules"=CV.rules,
                 "cv.stats"=CV.stats,
                 "cv.pval"=CV.pval)
  cat("Finished!\n")

  return(structure(list("x"=x, "times"=times, "status"=status,
                        "B"=B, "K"=K, "A"=A, "cpv"=cpv, "arg"=arg,
                        "cvtype"=cvtype, "cvcriterion"=cvcriterion,
                        "varsign"=varsign, "selected"=selected, "used"=used,
                        "probval"=probval, "timeval"=timeval,
                        "cvfit"=CV.fit, "cvprofiles"=CV.profiles,
                        "plot"=bool.plot, "seed"=seed),
                   class = "PRSP"))
}
##########################################################################################################################################




##########################################################################################################################################
# 2. SURVIVAL PLOTTING FUNCTIONS
##########################################################################################################################################

##########################################################################################################################################
#################
# Usage         :
################
#                    plot_profile (peelobj,
#                                  main=NULL, xlab="Peeling Steps", ylab="Mean Profiles",
#                                  add.sd=TRUE, add.legend=TRUE, add.profiles=TRUE,
#                                  pch=20, col=1, lty=1, lwd=2, cex=2, ...) {
#
#
################
# Description   :
################
#                   Plotting function of cross-validated profiles of specific statistics LHR, LRT or CER
#                   as a function of the model tuning parameter that is the optimal number of peeling steps
#                   of the model at each iteration of the peeling sequence (inner loop of our PRSP algorithm).
#                   Used for visualizing and/or choosing purpose of the optimal K-fold cross-validated number of steps
#                   or select the optimal model.
#                   The optimization criterion is done either by:
#                      - maximization of the LHR (between in and out box test samples)
#                      - maximization of the LRT (between in and out box test samples)
#                      - minimization of the CER (between predicted and observed inbox test samples survival times)
#
################
# Arguments     :
################
# peelobj       :   Object of class "PRSP" as generated by the main function sbh().
# main          :   Main Title. Defaults to NULL.
# xlab          :   X axis label. Defaults to "Peeling Steps".
# ylab          :   Y axis label. Defaults to "Mean Profiles".
# add.sd        :   Logical. Shall the standard error bars be plotted? Defaults to TRUE.
# add.legend    :   Logical. Shall the legend be plotted? Defaults to TRUE.
# add.profiles  :   Logical. Shall the individual profiles (for all replicates) be plotted? Defaults to TRUE.
# pch           :   Symbol number for all the profiles. Defaults to 20.
# cex           :   Symbol expansion for all the profiles. Defaults to 2.
# col           :   Line color of the mean profile. Defaults to 1.
#                   If more than eight profiles are plotted, line colors will be recycled.
# lty           :   Line type of the mean profile. Defaults to 1.
# lwd           :   Line width of the mean profile. Defaults to 2.
# ...           :   Generic arguments passed to other plotting functions.
#
################
# Values        :
################
#
##########################################################################################################################################

plot_profile <- function(peelobj,
                         main=NULL, xlab="Peeling Steps", ylab="Mean Profiles",
                         add.sd=TRUE, add.legend=TRUE, add.profiles=TRUE,
                         pch=20, col=1, lty=1, lwd=2, cex=2, ...) {

  if (is.null(peelobj$cvcriterion)) {
    cat("No CV here, so no cross-validated tuning profile to plot!\n")
  } else {
    if (peelobj$cvcriterion == "lhr") {
      txt <- "LHR"
      profiles <- peelobj$cvprofiles$lhr
      ylim <- range(0, profiles, na.rm=TRUE)
    } else if (peelobj$cvcriterion == "lrt") {
      txt <- "LRT"
      profiles <- peelobj$cvprofiles$lrt
      ylim <- range(0, profiles, na.rm=TRUE)
    } else if (peelobj$cvcriterion == "cer") {
      txt <- "CER"
      profiles <- peelobj$cvprofiles$cer
      ylim <- range(0, 1, profiles, na.rm=TRUE)
    } else {
      stop("Invalid CV criterion.\n")
    }

    if ((!is.null(main)) && (add.legend)) {
      par(mfrow=c(1, 1), oma=c(0, 0, 4, 0), mar=c(2.5, 2.5, 4.0, 1.5), mgp=c(1.5, 0.5, 0))
    } else if ((is.null(main)) && (!add.legend)) {
      par(mfrow=c(1, 1), oma=c(0, 0, 0, 0), mar=c(2.5, 2.5, 0.0, 1.5), mgp=c(1.5, 0.5, 0))
    } else {
      par(mfrow=c(1, 1), oma=c(0, 0, 1, 0), mar=c(2.5, 2.5, 1.0, 1.5), mgp=c(1.5, 0.5, 0))
    }

    Lm <- peelobj$cvfit$cv.maxsteps
    mean.profile <- apply(profiles, 2, mean, na.rm=TRUE)
    se.profile <- apply(profiles, 2, sd, na.rm=TRUE)

    if (add.profiles) {
      matplot(t(profiles), axes=FALSE, type="b",
              xlab="", ylab="", main="", ylim=ylim,
              pch=pch, lty=1, lwd=lwd/4, cex=cex/4)
      par(new=TRUE)
    }

    plot(0:(Lm-1), mean.profile, axes=FALSE, type="b",
         xlab=xlab, ylab=paste(txt ," ", ylab, sep=""), main=NULL, ylim=ylim,
         pch=pch, col=col, lty=lty, lwd=lwd, cex=cex)
    axis(side=1, pos=min(ylim), at=0:(Lm-1), labels=0:(Lm-1), cex.axis=1, line=NA)
    axis(side=2, pos=0, at=pretty(ylim), cex.axis=1, line=NA)
    segments(x0=peelobj$cvfit$cv.nsteps-1, y0=min(ylim), x1=peelobj$cvfit$cv.nsteps-1, y1=mean.profile[peelobj$cvfit$cv.nsteps], col=col, lty=2, lwd=lwd)

    if (add.sd) {
      arrows(0:(Lm-1), mean.profile, 0:(Lm-1), mean.profile - se.profile, length=0.1, angle=90, code=2, col=col, lwd=lwd)
      arrows(0:(Lm-1), mean.profile, 0:(Lm-1), mean.profile + se.profile, length=0.1, angle=90, code=2, col=col, lwd=lwd)
    }

    if (!is.null(main)) {
      if (add.legend) {
        title(main=main, xlab="", ylab="", line=3, outer=FALSE, xpd=TRUE)
        legend("top", xpd=TRUE, inset=-0.1, legend=c("Sample Mean", "Std. Error"), pch=pch, col=col, lty=lty, lwd=lwd, cex=0.6, pt.cex=cex/2)
      } else {
        title(main=main, xlab="", ylab="", line=1, outer=FALSE, xpd=TRUE)
      }
    } else {
      if (add.legend) {
        legend("top", xpd=TRUE, inset=0, legend=c("Sample Mean", "Std. Error"), pch=pch, col=col, lty=lty, lwd=lwd, cex=0.6, pt.cex=cex/2)
      }
    }
  }

  invisible()
}
##########################################################################################################################################





##########################################################################################################################################
#################
# Usage         :
################
#                    plot_scatter (peelobj,
#                                  main=NULL, xlab="", ylab="",
#                                  proj=c(1,2), boxes=TRUE, steps=peelobj$cvfit$cv.nsteps,
#                                  add.legend=TRUE, pch=16, cex=0.7, col=1, box.col=2, box.lty=2, box.lwd=1, ...)
#
#
################
# Description   :
################
#                   Plotting function for 2D visualization of the scatter of data and box vertices at a given peeling step.
#                   The plot is drawn with geometrically equal scales on the X and Y axes.
#
################
# Arguments     :
################
# peelobj       :   Object of class "PRSP" as generated by the main function sbh().
# main          :   Main Title. Defaults to NULL.
# xlab          :   X axis label. Defaults to "Box Mass".
# ylab          :   Y axis label. Defaults to "Variable range".
# proj          :   Integer vector of length two, specifying the dimensions of the projection plane. Defaults to c(1,2).
# splom         :   Logical. Shall the scatter plot of points inside the box(es) be plotted? Default to TRUE.
# boxes         :   Logical. Shall the box vertices be plotted or just the scatter of  points? Default to TRUE.
# steps         :   Integer vector. Vector of peeling steps at which one wants to plot the box vertices.
#                   Defaults to the last peeling step only.
# add.legend    :   Logical. Shall the legend of steps numbers be plotted? Defaults to TRUE.
# pch           :   Symbol number for the scatter plot. Defaults to 16.
# col           :   Symbol color. Defaults to 1.
# cex           :   Symbol expansion. Defaults to 0.7.
# box.col       :   Line color of the box vertices. Defaults to 2.
# box.lty       :   Line type of box vertices. Defaults to 2.
# box.lwd       :   Line width of box vertices. Defaults to 1.
# ...           :   Generic arguments passed to other plotting functions.
#
################
# Values        :
################
#
##########################################################################################################################################

plot_scatter <- function(peelobj,
                         main=NULL, xlab="", ylab="",
                         proj=c(1,2), splom=TRUE, boxes=TRUE, steps=peelobj$cvfit$cv.nsteps,
                         add.legend=TRUE, pch=16, cex=0.7, col=1, box.col=2, box.lty=2, box.lwd=1, ...) {

  if ((!is.null(main)) && (add.legend)) {
    par(mfrow=c(1, 1), oma=c(0, 0, 4, 0), mar=c(2.5, 2.5, 4.0, 1.5), mgp=c(1.5, 0.5, 0))
  } else if ((is.null(main)) && (!add.legend)) {
    par(mfrow=c(1, 1), oma=c(0, 0, 0, 0), mar=c(2.5, 2.5, 0.0, 1.5), mgp=c(1.5, 0.5, 0))
  } else {
    par(mfrow=c(1, 1), oma=c(0, 0, 1, 0), mar=c(2.5, 2.5, 1.0, 1.5), mgp=c(1.5, 0.5, 0))
  }

  x.names <- colnames(peelobj$x[,proj])
  if (missing(xlab))  xlab <- x.names[1]
  if (missing(ylab))  ylab <- x.names[2]

  L <- length(steps)
  if (length(box.col) < L) box.col <- rep(box.col, length=L)
  if (length(box.lty) < L) box.lty <- rep(box.lty, length=L)
  if (length(box.lwd) < L) box.lwd <- rep(box.lwd, length=L)

  eqscplot(peelobj$x[,proj], type="p",
           range(peelobj$x[,proj], peelobj$cvfit$cv.vertices$mean[[1]]),
           main=NULL, xlab=xlab, ylab=ylab, ...)

  if (splom) {
    for (i in 1:L) {
      w <- peelobj$cvfit$cv.boxind[steps[i],]
      points(peelobj$x[w,proj], type="p", pch=pch, cex=cex, col=box.col, ...)
    }
  }

  if (boxes) {
    for (i in 1:L) {
      vertices <- peelobj$cvfit$cv.vertices$mean[[steps[i]]][,proj]
      rect(vertices[1,1], vertices[1,2], vertices[2,1], vertices[2,2], border=box.col[i], col=NA, lty=box.lty[i], lwd=box.lwd[i])
    }
  }

  if (!is.null(main)) {
    if (add.legend) {
      title(main=main, xlab="", ylab="", line=3, outer=FALSE, xpd=TRUE)
      legend("top", xpd=TRUE, inset=-0.1, legend=paste("Steps: ", steps, sep=""), col=col, cex=cex)
    } else {
      title(main=main, xlab="", ylab="", line=1, outer=FALSE, xpd=TRUE)
    }
  } else {
    if (add.legend) {
      legend("top", xpd=TRUE, inset=0, legend=paste("Steps: ", steps, sep=""), col=col, cex=cex)
    }
  }
  legend("topright", inset=0.01, legend=c("outbox", "inbox"), pch=c(pch,pch), col=c(col,box.col), cex=cex)

  invisible()
}
##########################################################################################################################################




##########################################################################################################################################
#################
# Usage         :
################
#                    plot_boxtraj (peelobj, peelobj2=NULL, peelobj3=NULL,
#                                  main=NULL, xlab="Box Mass", ylab="Variable Range",
#                                  col=1, col2=col, col3=col, lty=1, lty2=lty, lty3=lty, lwd=1, lwd2=lwd, lwd3=lwd, cex=1, cex2=cex, cex3=cex,
#                                  add=FALSE, add.legend=FALSE, text.legend=NULL, nr=NULL, nc=NULL, ...)
#
################
# Description   :
################
#                   Plot the cross-validated peeling trajectories/profiles of covariates used for peeling and other statistical quantities of interest
#                   at each iteration of the peeling sequence (inner loop of our PRSP algorithm). Plot up to three "PRSP"" objects.
#
################
# Arguments     :
################
#                   Three objects of class "PRSP" as generated by the main function sbh().
# peelobj       :     Required
# peelobj2      :     Optional
# peelobj3      :     Optional
#
# main          :   Main Title. Defaults to NULL.
# xlab          :   X axis label. Defaults to "Box Mass".
# ylab          :   Y axis label. Defaults to "Variable range".
#
#                   Plotting parameters for the three objects
# col           :     Line color of object peelobj. Defaults to 1.
# col2          :     Line color of object peelobj2. Defaults to col.
# col3          :     Line color of object peelobj3. Defaults to col.
# lty           :     Line type of object peelobj. Defaults to 1.
# lty2          :     Line type of object peelobj2. Defaults to lty.
# lty3          :     Line type of object peelobj3. Defaults to lty.
# lwd           :     Line width of object peelobj. Defaults to 1.
# lwd2          :     Line width of object peelobj2. Defaults to lwd.
# lwd3          :     Line width of object peelobj3. Defaults to lwd.
# cex           :     Symbol expansion. Defaults to 1.
# cex2          :     Symbol expansion2. Defaults to cex.
# cex3          :     Symbol expansion3. Defaults to cex.
#
# add           :   Logical. Should this plot be added to an open graphics device?. Defaults to FALSE.
# add.legend    :   Logical. Should the legend be added to the current open graphics device?. Defaults to FALSE.
# text.legend   :   Character vector of legend content. Defaults to NULL.
# nr            :   numeric scalar of the number of rows in the plot.  If NULL, defaults to 3.
# nc            :   numeric scalar of the number of columns in the plot. If NULL, defaults to 3.
# ...           :   Generic arguments passed to other plotting functions.
#
################
# Values        :
################
#
##########################################################################################################################################

plot_boxtraj <- function(peelobj, peelobj2=NULL, peelobj3=NULL,
                         main=NULL, xlab="Box Mass", ylab="Variable Range",
                         col=1, col2=col, col3=col, lty=1, lty2=lty, lty3=lty, lwd=1, lwd2=lwd, lwd3=lwd, cex=1, cex2=cex, cex3=cex,
                         add=FALSE, add.legend=FALSE, text.legend=NULL, nr=NULL, nc=NULL, ...) {

  used <- peelobj$used
  p <- length(used)
  varnames <- colnames(peelobj$x)

  if (is.null(nc))
    nc <- 3
  if (is.null(nr)) {
    if (p %% nc == 0) {
      nr <- p%/%nc + 2
    } else {
      nr <- ((p+(1:nc))[which((p+(1:nc)) %% nc == 0)])%/%nc + 2
    }
  }

  if (!is.null(main)) {
    par(mfrow=c(nr, nc), oma=c(0, 0, 2, 0), mar=c(2.5, 2.5, 2.0, 1.5), mgp=c(1.5, 0.5, 0))
  } else {
    par(mfrow=c(nr, nc), oma=c(0, 0, 0, 0), mar=c(2.5, 2.5, 0.0, 1.5), mgp=c(1.5, 0.5, 0))
  }

  if (add) {
    for (j in used) {
      plot(peelobj$cvfit$cv.stats$mean$cv.support, peelobj$cvfit$cv.rules$mean[,j], type='s', col=col, lty=lty, lwd=lwd,
           main=paste(varnames[j], " variable trajectory", sep=""),
           xlim=range(0,1), ylim=range(peelobj$x[,j], peelobj2$x[,j], peelobj3$x[,j], na.rm=TRUE),
           xlab=xlab, ylab=ylab, cex.main=cex)
      points(peelobj2$cvfit$cv.stats$mean$cv.support, peelobj2$cvfit$cv.rules$mean[,j], type='s', col=col2, lty=lty2, lwd=lwd2)
      points(peelobj3$cvfit$cv.stats$mean$cv.support, peelobj3$cvfit$cv.rules$mean[,j], type='s', col=col3, lty=lty3, lwd=lwd3)
      if (add.legend)
        legend("bottomleft", inset=0.01, legend=text.legend, lty=c(lty,lty2,lty3), col=c(col,col2,col3), lwd=c(lwd,lwd2,lwd3), cex=0.7)
    }
  } else {
    for (j in used) {
      plot(peelobj$cvfit$cv.stats$mean$cv.support, peelobj$cvfit$cv.rules$mean[,j], type='s', col=col, lty=lty,
           main=paste(varnames[j], " variable trajectory", sep=""),
           xlim=range(0,1), ylim=range(peelobj$x[,j], na.rm=TRUE),
           xlab=xlab, ylab=ylab, cex.main=cex)
      if (add.legend)
        legend("bottomleft", inset=0.01, legend=text.legend, lty=lty, col=col, lwd=lwd, cex=0.7)
    }
  }

  par(mfg=c(nr-1, 1))
  if (add) {
    plot(peelobj$cvfit$cv.stats$mean$cv.support, peelobj$cvfit$cv.stats$mean$cv.support, type='s', col=col, lty=lty, lwd=lwd,
         main="Box support trajectory",
         xlim=range(0,1), ylim=range(0, 1),
         xlab=xlab, ylab=expression(paste("Support (", beta, ")", sep="")), cex.main=cex)
    points(peelobj2$cvfit$cv.stats$mean$cv.support, peelobj2$cvfit$cv.stats$mean$cv.support, type='s', col=col2, lty=lty2, lwd=lwd2)
    points(peelobj3$cvfit$cv.stats$mean$cv.support, peelobj3$cvfit$cv.stats$mean$cv.support, type='s', col=col3, lty=lty3, lwd=lwd3)
    if (add.legend)
      legend("bottomright", inset=0.01, legend=text.legend, lty=c(lty,lty2,lty3), col=c(col,col2,col3), lwd=c(lwd,lwd2,lwd3), cex=0.7)
  } else {
    plot(peelobj$cvfit$cv.stats$mean$cv.support, peelobj$cvfit$cv.stats$mean$cv.support, type='s', col=col, lty=lty, lwd=lwd,
         main="Box support trajectory",
         xlim=range(0,1), ylim=range(0, 1),
         xlab=xlab, ylab=expression(paste("Support (", beta, ")", sep="")), cex.main=cex)
    if (add.legend)
      legend("bottomright", inset=0.01, legend=text.legend, lty=lty, col=col, lwd=lwd, cex=0.7)
  }

  par(mfg=c(nr-1, 2))
  if (add) {
    plot(peelobj$cvfit$cv.stats$mean$cv.support, peelobj$cvfit$cv.stats$mean$cv.max.time.bar, type='s', col=col, lty=lty, lwd=lwd,
         main="MEFT trajectory",
         xlim=range(0,1), ylim=range(0, peelobj$cvfit$cv.stats$mean$cv.max.time.bar, peelobj2$cvfit$cv.stats$mean$cv.max.time.bar, peelobj3$cvfit$cv.stats$mean$cv.max.time.bar, na.rm=TRUE),
         xlab=xlab, ylab="Time", cex.main=cex)
    points(peelobj2$cvfit$cv.stats$mean$cv.support, peelobj2$cvfit$cv.stats$mean$cv.max.time.bar, type='s', col=col2, lty=lty2, lwd=lwd2)
    points(peelobj3$cvfit$cv.stats$mean$cv.support, peelobj3$cvfit$cv.stats$mean$cv.max.time.bar, type='s', col=col3, lty=lty3, lwd=lwd3)
    if (add.legend)
      legend("bottomright", inset=0.01, legend=text.legend, lty=c(lty,lty2,lty3), col=c(col,col2,col3), lwd=c(lwd,lwd2,lwd3), cex=0.7)
  } else {
    plot(peelobj$cvfit$cv.stats$mean$cv.support, peelobj$cvfit$cv.stats$mean$cv.max.time.bar, type='s', col=col, lty=lty, lwd=lwd,
         main="MEFT trajectory",
         xlim=range(0,1), ylim=range(0, peelobj$cvfit$cv.stats$mean$cv.max.time.bar, na.rm=TRUE),
         xlab=xlab, ylab="Time", cex.main=cex)
    if (add.legend)
      legend("bottomright", inset=0.01, legend=text.legend, lty=lty, col=col, lwd=lwd, cex=0.7)
  }

  par(mfg=c(nr-1, 3))
  if (add) {
    plot(peelobj$cvfit$cv.stats$mean$cv.support, peelobj$cvfit$cv.stats$mean$cv.min.prob.bar, type='s', col=col, lty=lty, lwd=lwd,
         main="MEFP trajectory",
         xlim=range(0,1), ylim=range(0,1),
         xlab=xlab, ylab="Probability", cex.main=cex)
    points(peelobj2$cvfit$cv.stats$mean$cv.support, peelobj2$cvfit$cv.stats$mean$cv.min.prob.bar, type='s', col=col2, lty=lty2, lwd=lwd2)
    points(peelobj3$cvfit$cv.stats$mean$cv.support, peelobj3$cvfit$cv.stats$mean$cv.min.prob.bar, type='s', col=col3, lty=lty3, lwd=lwd3)
    if (add.legend)
      legend("bottomright", inset=0.01, legend=text.legend, lty=c(lty,lty2,lty3), col=c(col,col2,col3), lwd=c(lwd,lwd2,lwd3), cex=0.7)
  } else {
    plot(peelobj$cvfit$cv.stats$mean$cv.support, peelobj$cvfit$cv.stats$mean$cv.min.prob.bar, type='s', col=col, lty=lty, lwd=lwd,
         main="MEFP trajectory",
         xlim=range(0,1), ylim=range(0,1),
         xlab=xlab, ylab="Probability", cex.main=cex)
    if (add.legend)
      legend("bottomright", inset=0.01, legend=text.legend, lty=lty, col=col, lwd=lwd, cex=0.7)
  }

  par(mfg=c(nr, 1))
  if (add) {
    plot(peelobj$cvfit$cv.stats$mean$cv.support, peelobj$cvfit$cv.stats$mean$cv.lhr, type='s', col=col, lty=lty, lwd=lwd,
         main="LHR trajectory",
         xlim=range(0,1), ylim=range(0, peelobj$cvfit$cv.stats$mean$cv.lhr, peelobj2$cvfit$cv.stats$mean$cv.lhr, peelobj3$cvfit$cv.stats$mean$cv.lhr, na.rm=TRUE),
         xlab=xlab, ylab=expression(paste("Log-Hazard Ratio (", lambda,")", sep="")), cex.main=cex)
    points(peelobj2$cvfit$cv.stats$mean$cv.support, peelobj2$cvfit$cv.stats$mean$cv.lhr, type='s', col=col2, lty=lty2, lwd=lwd2)
    points(peelobj3$cvfit$cv.stats$mean$cv.support, peelobj3$cvfit$cv.stats$mean$cv.lhr, type='s', col=col3, lty=lty3, lwd=lwd3)
    if (add.legend)
      legend("top", inset=0.01, legend=text.legend, lty=c(lty,lty2,lty3), col=c(col,col2,col3), lwd=c(lwd,lwd2,lwd3), cex=0.7)
  } else {
    plot(peelobj$cvfit$cv.stats$mean$cv.support, peelobj$cvfit$cv.stats$mean$cv.lhr, type='s', col=col, lty=lty, lwd=lwd,
         main="LHR trajectory", xlim=range(0,1), ylim=range(0, peelobj$cvfit$cv.stats$mean$cv.lhr, na.rm=TRUE),
         xlab=xlab, ylab=expression(paste("Log-Hazard Ratio (", lambda,")", sep="")), cex.main=cex)
    if (add.legend)
      legend("top", inset=0.01, legend=text.legend, lty=lty, col=col, lwd=lwd, cex=0.7)
  }

  par(mfg=c(nr, 2))
  if (add) {
    plot(peelobj$cvfit$cv.stats$mean$cv.support, peelobj$cvfit$cv.stats$mean$cv.lrt, type='s', col=col, lty=lty, lwd=lwd,
         main="LRT trajectory",
         xlim=range(0,1), ylim=range(0, peelobj$cvfit$cv.stats$mean$cv.lrt, peelobj2$cvfit$cv.stats$mean$cv.lrt, peelobj3$cvfit$cv.stats$mean$cv.lrt, na.rm=TRUE),
         xlab=xlab, ylab=expression(paste("Log-rank test (", chi^2 ,")", sep="")), cex.main=cex)
    points(peelobj2$cvfit$cv.stats$mean$cv.support, peelobj2$cvfit$cv.stats$mean$cv.lrt, type='s', col=col2, lty=lty2, lwd=lwd2)
    points(peelobj3$cvfit$cv.stats$mean$cv.support, peelobj3$cvfit$cv.stats$mean$cv.lrt, type='s', col=col3, lty=lty3, lwd=lwd3)
    if (add.legend)
      legend("top", inset=0.01, legend=text.legend, lty=c(lty,lty2,lty3), col=c(col,col2,col3), lwd=c(lwd,lwd2,lwd3), cex=0.7)
  } else {
    plot(peelobj$cvfit$cv.stats$mean$cv.support, peelobj$cvfit$cv.stats$mean$cv.lrt, type='s', col=col, lty=lty, lwd=lwd,
         main="LRT trajectory",
         xlim=range(0,1), ylim=range(0, peelobj$cvfit$cv.stats$mean$cv.lrt, na.rm=TRUE),
         xlab=xlab, ylab=expression(paste("Log-rank test (", chi^2 ,")", sep="")), cex.main=cex)
    if (add.legend)
      legend("top", inset=0.01, legend=text.legend, lty=lty, col=col, lwd=lwd, cex=0.7)
  }

  par(mfg=c(nr, 3))
  if (add) {
    plot(peelobj$cvfit$cv.stats$mean$cv.support, peelobj$cvfit$cv.stats$mean$cv.cer, type='s', col=col, lty=lty, lwd=lwd,
         main="CER trajectory",
         xlim=range(0,1), ylim=range(0, 1),
         xlab=xlab, ylab=expression(paste("1-C (", theta,")", sep="")), cex.main=cex)
    points(peelobj2$cvfit$cv.stats$mean$cv.support, peelobj2$cvfit$cv.stats$mean$cv.cer, type='s', col=col2, lty=lty2, lwd=lwd2)
    points(peelobj3$cvfit$cv.stats$mean$cv.support, peelobj3$cvfit$cv.stats$mean$cv.cer, type='s', col=col3, lty=lty3, lwd=lwd3)
    if (add.legend)
      legend("top", inset=0.01, legend=text.legend, lty=c(lty,lty2,lty3), col=c(col,col2,col3), lwd=c(lwd,lwd2,lwd3), cex=0.7)
  } else {
    plot(peelobj$cvfit$cv.stats$mean$cv.support, peelobj$cvfit$cv.stats$mean$cv.cer, type='s', col=col, lty=lty, lwd=lwd,
         main="CER trajectory",
         xlim=range(0,1), ylim=range(0, 1),
         xlab=xlab, ylab=expression(paste("1-C (", theta,")", sep="")), cex.main=cex)
    if (add.legend)
      legend("top", inset=0.01, legend=text.legend, lty=lty, col=col, lwd=lwd, cex=0.7)
  }

  mtext(text=main, cex=1, side=3, outer=TRUE)
  invisible()
}
##########################################################################################################################################





##########################################################################################################################################
#################
# Usage         :
################
#                    plot_boxtrace (peelobj, peelobj2=NULL, peelobj3=NULL,
#                                   main=NULL, xlab="Box Mass", ylab="Variable Range",
#                                   center=FALSE, scale=FALSE, hline=NULL,
#                                   col=1, col2=col, col3=col, lty=1, lty2=lty, lty3=lty, lwd=1, lwd2=lwd, lwd3=lwd, cex=1, cex2=cex, cex3=cex,
#                                   add=FALSE, add.legend=FALSE, text.legend=NULL, ...)
#
################
# Description   :
################
#                    Plot the cross-validated modal trace curves of variable importance and variable usage
#                    of covariates used for peeling at each iteration of the peeling sequence
#                    (inner loop of our PRSP algorithm).
#                    Plot up to three "PRSP"" objects.
#
################
# Arguments     :
################
#                   Three objects of class "PRSP" as generated by the main function sbh().
# peelobj       :     Required
# peelobj2      :     Optional
# peelobj3      :     Optional
#
# main          :   Main Title. Defaults to NULL.
# xlab          :   X axis label. Defaults to "Box Mass".
# ylab          :   Y axis label. Defaults to "Variable range".
# center        :   Logical. Shall the data be centered before?
# scale         :   Logical. Shall the data be scaled before?
# hline         :   numeric scalar of where the data is centred.
#                   If specified (i.e. not NULL), an horizontal line about this value is added to the plot.
#
#                   Plotting parameters for the three objects:
# col           :     Line color of object peelobj. Defaults to 1.
# col2          :     Line color of object peelobj2. Defaults to col.
# col3          :     Line color of object peelobj3. Defaults to col.
# lty           :     Line type of object peelobj. Defaults to 1.
# lty2          :     Line type of object peelobj2. Defaults to lty.
# lty3          :     Line type of object peelobj3. Defaults to lty.
# lwd           :     Line width of object peelobj. Defaults to 1.
# lwd2          :     Line width of object peelobj2. Defaults to lwd.
# lwd3          :     Line width of object peelobj3. Defaults to lwd.
# cex           :     Symbol expansion. Defaults to 1.
# cex2          :     Symbol expansion2. Defaults to cex.
# cex3          :     Symbol expansion3. Defaults to cex.
#
# add           :   Logical. Should all the PRSP trace plots be overlaid?. Defaults to FALSE.
# add.legend    :   Logical. Should the legend be added to the current open graphics device?. Defaults to FALSE.
# text.legend   :   Character vector of legend content. Defaults to NULL.
# ...           :   Generic arguments passed to other plotting functions.
#
################
# Values        :
################
#
##########################################################################################################################################

plot_boxtrace <- function(peelobj, peelobj2=NULL, peelobj3=NULL,
                          main=NULL, xlab="Box Mass", ylab="Variable Range",
                          center=FALSE, scale=FALSE, hline=NULL,
                          col=1, col2=col, col3=col, lty=1, lty2=lty, lty3=lty, lwd=1, lwd2=lwd, lwd3=lwd, cex=1, cex2=cex, cex3=cex,
                          add=FALSE, add.legend=FALSE, text.legend=NULL, ...) {

  used <- peelobj$used
  p <- length(used)
  varnames <- colnames(peelobj$x)
  maxtick <- max(used)
  ticknames <- rep("", maxtick)
  ticknames[used] <- paste(varnames[used], " -", sep="")

  if (!is.null(main)) {
    par(mfrow=c(2, 1), oma=c(0, 0, 2, 0), mar=c(2.5, 4.0, 2.0, 0), mgp=c(1.5, 0.5, 0))
  } else {
    par(mfrow=c(2, 1), oma=c(0, 0, 0, 0), mar=c(2.5, 4.0, 0.0, 0), mgp=c(1.5, 0.5, 0))
  }

  if (add) {
    x1 <- scale(x=peelobj$cvfit$cv.rules$mean, center=center, scale=scale)
    x2 <- scale(x=peelobj2$cvfit$cv.rules$mean, center=center, scale=scale)
    x3 <- scale(x=peelobj3$cvfit$cv.rules$mean, center=center, scale=scale)
    plot(peelobj$cvfit$cv.stats$mean$cv.support, x1[,1], type='n',
         xlim=range(0,1), ylim=range(x1, x2, x3, hline),
         main="Variable Importance", xlab="", ylab="", cex.main=cex)
    for (j in used) {
      lines(peelobj$cvfit$cv.stats$mean$cv.support, x1[,j], type='l', col=col[j], lty=lty[j], lwd=lwd[j])
      lines(peelobj2$cvfit$cv.stats$mean$cv.support, x2[,j], type='l', col=col2[j], lty=lty2[j], lwd=lwd2[j])
      lines(peelobj3$cvfit$cv.stats$mean$cv.support, x3[,j], type='l', col=col3[j], lty=lty3[j], lwd=lwd3[j])
      abline(h=hline[j], lty=1, col=1, lwd=0.3, xpd=FALSE)
      legend("topleft", inset=0.01, legend=varnames[used], lty=lty, col=col, lwd=lwd, cex=0.5*cex)
      legend("top", inset=0.01, legend=varnames[used], lty=lty2, col=col2, lwd=lwd2, cex=0.5*cex)
      legend("topright", inset=0.01, legend=varnames[used], lty=lty3, col=col3, lwd=lwd3, cex=0.5*cex)
    }
    if (add.legend)
      legend("bottom", inset=0.01, legend=text.legend, lty=c(lty[1],lty2[1],lty3[1]), col=c(1,1,1), lwd=c(lwd[1],lwd2[1],lwd3[1]), cex=0.5*cex)
    mtext(text=xlab, cex=cex, side=1, line=1, outer=FALSE)
    mtext(text=ylab, cex=cex, side=2, line=2, outer=FALSE)
  } else {
    x1 <- scale(x=peelobj$cvfit$cv.rules$mean, center=center, scale=scale)
    plot(peelobj$cvfit$cv.stats$mean$cv.support, x1[,1], type='n',
         xlim=range(0,1), ylim=range(x1, hline),
         main="Variable Importance", xlab="", ylab="", cex.main=cex)
    for (j in used) {
      lines(peelobj$cvfit$cv.stats$mean$cv.support, x1[,j], type='l', col=col[j], lty=lty[j], lwd=lwd[j])
      abline(h=hline[j], lty=1, col=1, lwd=0.3, xpd=FALSE)
      legend("top", inset=0.01, legend=varnames[used], lty=lty, col=col, lwd=lwd, cex=0.5*cex)
    }
    if (add.legend)
      legend("bottom", inset=0.01, legend=text.legend, lty=lty[1], col=1, lwd=lwd[1], cex=0.5*cex)
    mtext(text=xlab, cex=cex, side=1, line=1, outer=FALSE)
    mtext(text=ylab, cex=cex, side=2, line=2, outer=FALSE)
  }

  if (add) {
    plot(peelobj$cvfit$cv.stats$mean$cv.support[-peelobj$cvfit$cv.nsteps], peelobj$cvfit$cv.trace$mode[-1],
         type='s', yaxt="n", col=1, lty=lty[1], lwd=lwd[1],
         xlim=range(0,1), ylim=range(0, maxtick),
         main="Variable Usage", xlab="", ylab="", cex.main=cex)
    points(peelobj2$cvfit$cv.stats$mean$cv.support[-peelobj2$cvfit$cv.nsteps], peelobj2$cvfit$cv.trace$mode[-1], type='s', col=1, lty=lty2[1], lwd=lwd2[1])
    points(peelobj3$cvfit$cv.stats$mean$cv.support[-peelobj3$cvfit$cv.nsteps], peelobj3$cvfit$cv.trace$mode[-1], type='s', col=1, lty=lty3[1], lwd=lwd3[1])
    par(mgp=c(1.5, 0, 0))
    axis(side=2, at=1:maxtick, labels=ticknames, tick=FALSE, las=1, line=NA, cex.axis=0.5*cex, outer=FALSE)
    if (add.legend)
      legend("bottom", inset=0.01, legend=text.legend, lty=c(lty[1],lty2[1],lty3[1]), col=c(1,1,1), lwd=c(lwd[1],lwd2[1],lwd3[1]), cex=0.5*cex)
    mtext(text=xlab, cex=cex, side=1, line=1, outer=FALSE)
    mtext(text="Variables", cex=cex, side=2, line=3, outer=FALSE)
  } else {
    plot(peelobj$cvfit$cv.stats$mean$cv.support[-peelobj$cvfit$cv.nsteps], peelobj$cvfit$cv.trace$mode[-1],
         type='s', yaxt="n", col=1, lty=lty[1], lwd=lwd[1],
         xlim=range(0,1), ylim=range(0, maxtick),
         main="Variable Usage", xlab="", ylab="", cex.main=cex)
    par(mgp=c(1.5, 0, 0))
    axis(side=2, at=1:maxtick, labels=ticknames, tick=FALSE, las=1, line=NA, cex.axis=0.5*cex, outer=FALSE)
    if (add.legend)
      legend("bottom", inset=0.01, legend=text.legend, lty=lty[1], col=1, lwd=lwd[1], cex=0.5*cex)
    mtext(text=xlab, cex=cex, side=1, line=1, outer=FALSE)
    mtext(text="Variables", cex=cex, side=2, line=3, outer=FALSE)
  }

  mtext(text=main, cex=1, side=3, outer=TRUE)
  invisible()
}
##########################################################################################################################################





##########################################################################################################################################
#################
# Usage         :
################
#                    plot_boxkm (peelobj,
#                                main=NULL, xlab="Time", ylab="Probability",
#                                precision, mark=3, col=1, lty=1, lwd=1, cex=1,
#                                only.last=FALSE, nr=NULL, nc=NULL, ...)
#
################
# Description   :
################
#                   Plotting function of Kaplan-Meier survival curves.
#                   See survival::plot.survfit() for additioal details.
#
################
# Arguments     :
################
# peelobj       :   An object of class "PRSP" as generated by the main function sbh().
# main          :   Main Title. Defaults to NULL.
# xlab          :   X axis label. Defaults to "Time".
# ylab          :   Y axis label. Defaults to "Probability"
# precision     :   Precision of cross-validated log-rank p-values of separation between two survival curves.
#                     Lower bounded by the value 1/A of the number of replication A.
#
#                   The following are further defined in package "survival":
# mark          :     vector of mark parameters, which will be used to label the curves. Defaults to 3.
# col           :     vector of integers specifying colors for each curve. Defaults to 1.
# lty           :     vector of integers specifying line types for each curve. Defaults to 1.
# lwd           :     vector of numeric values for line widths. Defaults to 1.
# cex           :     numeric value specifying the size of the marks. Defults to 1.
#
# only.last     :   Logical defining whether only the last step of the peeling sequence should be plotted. Defaults to FALSE.
# nr            :   numeric scalar of the number of rows in the plot. If NULL, defaults to 3.
# nc            :   numeric scalar of the number of columns in the plot. If NULL, defaults to 4.
# ...           :   Generic arguments passed to other functions, including survival::plot.survfit().
#
################
# Values        :
################
#
##########################################################################################################################################

plot_boxkm <- function(peelobj,
                       main=NULL, xlab="Time", ylab="Probability",
                       precision, mark=3, col=1, lty=1, lwd=1, cex=1,
                       only.last=FALSE, nr=NULL, nc=NULL, ...) {

  # set default values for missing parameters
  if (missing(precision)) {
    precision <- 1/peelobj$A
  }
  if (missing(mark) || length(mark) == 1) {
    mark <- c(mark, mark+1)
  }
  if (missing(col) || length(col) == 1) {
    col <- c(col, col+1)
  }
  if (missing(lty) || length(lty) == 1) {
    lty <- c(lty, lty+1)
  }

  used <- peelobj$used
  p <- length(used)

  if (is.null(nc))
    nc <- 4
  if (is.null(nr)) {
    if (p %% nc == 0) {
      nr <- p%/%nc + 2
    } else {
      nr <- ((p+(1:nc))[which((p+(1:nc)) %% nc == 0)])%/%nc + 2
    }
  }

  times <- peelobj$times
  status <- peelobj$status
  L <- peelobj$cvfit$cv.nsteps

  if (only.last) {
    steps <- L
  } else {
    steps <- 1:L
    if (!is.null(main)) {
      par(mfrow=c(nr, nc), oma=c(0, 0, 2, 0), mar=c(2.5, 2.5, 1.5, 1.5), mgp=c(1.5, 0.5, 0))
    } else {
      par(mfrow=c(nr, nc), oma=c(0, 0, 0, 0), mar=c(2.5, 2.5, 0.0, 1.5), mgp=c(1.5, 0.5, 0))
    }
  }

  for (l in steps) {
    boxind <- peelobj$cvfit$cv.boxind[l,]
    ng <- length(unique(boxind[!is.na(boxind)]))
    if (ng == 1) {
      boxind <- 1*boxind
    } else {
      boxind <- 2 - 1*boxind
    }
    surv <- survfit(Surv(times, status) ~ 1 + boxind)
    if (l == 1) {
      plot(surv, main="", conf.int=TRUE, mark.time=TRUE, lty=2, col=2, xlab=xlab, ylab=ylab, cex=cex, ...)
      par(new=TRUE)
      plot(surv, main="", conf.int=FALSE, mark.time=TRUE, lty=1, col=2, xlab=xlab, ylab=ylab, cex=cex, ...)
    } else {
      plot(surv, main="", conf.int=TRUE, mark.time=TRUE, lty=c(2,2), col=c(2,1), xlab=xlab, ylab=ylab, cex=cex, ...)
      par(new=TRUE)
      plot(surv, main="", conf.int=FALSE, mark.time=TRUE, lty=c(1,1), col=c(2,1), xlab=xlab, ylab=ylab, cex=cex, ...)
    }
    legend("topright", inset=0.01, legend=c("outbox", "inbox"), lty=c(1,1), col=c(1,2), cex=0.9*cex)
    if (peelobj$cpv) {
      if (peelobj$cvfit$cv.pval[l] <= precision) {
        legend("bottom", inset=0.11, col="black", cex=0.9*cex, bty="n",
               legend=bquote(italic(p) <= .(precision)))
      } else {
        legend("bottom", inset=0.11, col="black", cex=0.9*cex, bty="n",
               legend=bquote(italic(p) == .(format(x=peelobj$cvfit$cv.pval[l], scientific=FALSE, digits=4, nsmall=4))))
      }
    }
    legend("bottom", inset=0.01, col="black", cex=0.9*cex, bty="n",
           legend=substitute(group("", list(paste(italic(LHR) == x, sep="")), ""), list(x=format(x=peelobj$cvfit$cv.stats$mean$cv.lhr[l], digits=3, nsmall=3))))
    legend("bottom", inset=0.06, col="black", cex=0.9*cex, bty="n",
           legend=substitute(group("", list(paste(italic(LRT) == x, sep="")), ""), list(x=format(x=peelobj$cvfit$cv.stats$mean$cv.lrt[l], digits=3, nsmall=3))))
    legend("bottom", inset=0.16, legend=paste("Step ", l-1, sep=""), col=1, cex=0.9*cex, bty="n")
  }

  if (only.last) {
    if (!is.null(main)) {
      mtext(text=main, cex=cex, side=3, line=1, outer=FALSE)
    }
  } else {
    if (!is.null(main)) {
      mtext(text=main, cex=cex, side=3, outer=TRUE)
    }
  }

  invisible()
}
##########################################################################################################################################






##########################################################################################################################################
# 3. SURVIVAL INTERNAL SUBROUTINES
# (never to be called by end-user)
##########################################################################################################################################

##########################################################################################################################################
#################
# Usage         :
################
#                   cv.box.rep(x, times, status,
#                              B, K, arg,
#                              cvtype,
#                              probval, timeval,
#                              varsign, selected, initcutpts,
#                              parallel, seed)
#
################
# Description   :
################
#
################
# Arguments     :
################
#
################
# Values        :
################
#
##########################################################################################################################################

cv.box.rep <- function(x, times, status,
                       B, K, arg,
                       cvtype,
                       probval, timeval,
                       varsign, selected, initcutpts,
                       parallel, seed) {

  CV.maxsteps <- numeric(B)
  CV.nsteps.lhr <- numeric(B)
  CV.nsteps.lrt <- numeric(B)
  CV.nsteps.cer <- numeric(B)
  CV.trace <- vector(mode="list", length=B)
  CV.boxind <- vector(mode="list", length=B)
  CV.boxcut <- vector(mode="list", length=B)
  CV.vertices <- vector(mode="list", length=B)
  CV.support <- vector(mode="list", length=B)
  CV.lhr <- vector(mode="list", length=B)
  CV.lrt <- vector(mode="list", length=B)
  CV.cer <- vector(mode="list", length=B)
  CV.time.bar <- vector(mode="list", length=B)
  CV.prob.bar <- vector(mode="list", length=B)
  CV.max.time.bar <- vector(mode="list", length=B)
  CV.min.prob.bar <- vector(mode="list", length=B)
  b <- 1
  j <- 0
  success <- TRUE
  while (b <= B) {
    cat("replicate : ", b, "\n", sep="")
    if (!parallel) {
      set.seed(seed[b])
      cat("seed : ", seed[b], "\n", sep="")
    }
    if (cvtype == "averaged") {
      CVBOX <- cv.ave.box(x=x, times=times, status=status,
                          K=K, arg=arg,
                          probval=probval, timeval=timeval,
                          varsign=varsign, selected=selected, initcutpts=initcutpts,
                          seed=seed[b])
    } else if (cvtype == "combined") {
      CVBOX <- cv.comb.box(x=x, times=times, status=status,
                           K=K, arg=arg,
                           probval=probval, timeval=timeval,
                           varsign=varsign, selected=selected, initcutpts=initcutpts,
                           seed=seed[b])
    } else if (cvtype == "none") {
      CVBOX <- cv.comb.box(x=x, times=times, status=status,
                           K=1, arg=arg,
                           probval=probval, timeval=timeval,
                           varsign=varsign, selected=selected, initcutpts=initcutpts,
                           seed=seed[b])
    } else {
      stop("Invalid CV type option \n")
    }
    if (!CVBOX$drop) {
      CV.maxsteps[b] <- CVBOX$cvfit$cv.maxsteps
      CV.nsteps.lhr[b] <- CVBOX$cvfit$cv.nsteps.lhr
      CV.nsteps.lrt[b] <- CVBOX$cvfit$cv.nsteps.lrt
      CV.nsteps.cer[b] <- CVBOX$cvfit$cv.nsteps.cer
      CV.trace[[b]] <- CVBOX$cvfit$cv.trace
      CV.boxind[[b]] <- CVBOX$cvfit$cv.boxind
      CV.boxcut[[b]] <- CVBOX$cvfit$cv.boxcut
      CV.vertices[[b]] <- CVBOX$cvfit$cv.vertices
      CV.support[[b]] <- CVBOX$cvfit$cv.stats$cv.support
      CV.lhr[[b]] <- CVBOX$cvfit$cv.stats$cv.lhr
      CV.lrt[[b]] <- CVBOX$cvfit$cv.stats$cv.lrt
      CV.cer[[b]] <- CVBOX$cvfit$cv.stats$cv.cer
      CV.time.bar[[b]] <- CVBOX$cvfit$cv.stats$cv.time.bar
      CV.prob.bar[[b]] <- CVBOX$cvfit$cv.stats$cv.prob.bar
      CV.max.time.bar[[b]] <- CVBOX$cvfit$cv.stats$cv.max.time.bar
      CV.min.prob.bar[[b]] <- CVBOX$cvfit$cv.stats$cv.min.prob.bar
      b <- b + 1
      j <- 0
    } else {
      cat("Could not find one step in at least one of the folds within replicate #", b ,". Retrying replicate with new seed\n", sep="")
      seed[b] <- seed[b] + B
      j <- j + 1
      if (j == B) {
        cat("Could not complete requested replications after ", B ," successive trials. Exiting replications\n", sep="")
        b <- B
        success <- FALSE
      }
    }
  }

  return(list("cv.maxsteps"=CV.maxsteps,
              "cv.nsteps.lhr"=CV.nsteps.lhr,
              "cv.nsteps.lrt"=CV.nsteps.lrt,
              "cv.nsteps.cer"=CV.nsteps.cer,
              "cv.trace"=CV.trace,
              "cv.boxind"=CV.boxind,
              "cv.boxcut"=CV.boxcut,
              "cv.vertices"=CV.vertices,
              "cv.support"=CV.support,
              "cv.lhr"=CV.lhr,
              "cv.lrt"=CV.lrt,
              "cv.cer"=CV.cer,
              "cv.time.bar"=CV.time.bar,
              "cv.prob.bar"=CV.prob.bar,
              "cv.max.time.bar"=CV.max.time.bar,
              "cv.min.prob.bar"=CV.min.prob.bar,
              "success"=success,
              "seed"=seed))
}
##########################################################################################################################################




##########################################################################################################################################
#################
# Usage         :
################
#                    cv.pval (x, times, status,
#                             cvtype,
#                             varsign, selected, initcutpts,
#                             A, K, arg, obs.chisq,
#                             parallel, conf)
#
################
# Description   :
################
#                   Parallel computation of the cross-validated LRT p-value at a given peeling step
#
################
# Arguments     :
################
#
################
# Values        :
################
#
##########################################################################################################################################

cv.pval <- function(x, times, status,
                    cvtype,
                    varsign, selected, initcutpts,
                    A, K, arg, obs.chisq,
                    parallel, conf) {

  if (!parallel) {
    null.chisq <- cv.null(x=x, times=times, status=status,
                          cvtype=cvtype,
                          varsign=varsign, selected=selected, initcutpts=initcutpts,
                          A=A, K=K, arg=arg)
  } else {
    if (conf$type == "SOCK") {
      cl <- makeCluster(spec=conf$names,
                        type=conf$type,
                        homogeneous=conf$homo,
                        outfile=conf$outfile,
                        verbose=conf$verbose)
    } else {
      cl <- makeCluster(spec=conf$cpus,
                        type=conf$type,
                        homogeneous=conf$homo,
                        outfile=conf$outfile,
                        verbose=conf$verbose)
    }
    clusterSetRNGStream(cl=cl, iseed=NULL)
    null.cl <- clusterCall(cl=cl, fun=cv.null,
                           x=x, times=times, status=status,
                           cvtype=cvtype,
                           varsign=varsign, selected=selected, initcutpts=initcutpts,
                           A=ceiling(A/conf$cpus), K=K, arg=arg)
    stopCluster(cl)
    null.chisq <- cbindlist(null.cl)
  }
  cvl <- nrow(null.chisq)
  pval <- numeric(cvl)
  for (l in 1:cvl) {
    pval[l] <- mean((null.chisq[l,] >= obs.chisq[l]), na.rm=TRUE)
  }

  return(pval)
}
##########################################################################################################################################




##########################################################################################################################################
#################
# Usage         :
################
#                   cv.null (x, times, status,
#                            cvtype,
#                            varsign, selected, initcutpts,
#                            A, K, arg)
#
################
# Description   :
################
#                   Internal subroutine for computation of the cross-validated LRT null distribution at a given peeling step
#
################
# Arguments     :
################
#
################
# Values        :
################
#
##########################################################################################################################################

cv.null <- function(x, times, status,
                    cvtype,
                    varsign, selected, initcutpts,
                    A, K, arg) {

  n <- nrow(x)
  null.chisq <- vector(mode="list", length=A)
  a <- 1
  while (a <= A) {
    cat("Permutation sample: ", a, "\n")
    perm.ind <- sample(x = 1:n, size = n, replace = FALSE, prob = NULL)
    perm.times <- times[perm.ind]
    perm.status <- status[perm.ind]
    if (cvtype == "averaged") {
      obj <- tryCatch({cv.ave.box(x=x, times=perm.times, status=perm.status, varsign=varsign, selected=selected, initcutpts=initcutpts, K=K, arg=arg, probval=NULL, timeval=NULL, seed=NULL)}, error=function(w){NULL})
      if (is.list(obj)) {
        null.chisq[[a]] <- obj$cvfit$cv.stats$cv.lrt
        a <- a + 1
      } else {
        cat("Permutation sample dropped... \n")
      }
    } else if (cvtype == "combined") {
      obj <- tryCatch({cv.comb.box(x=x, times=perm.times, status=perm.status, varsign=varsign, selected=selected, initcutpts=initcutpts, K=K, arg=arg, probval=NULL, timeval=NULL, seed=NULL)}, error=function(w){NULL})
      if (is.list(obj)) {
        null.chisq[[a]] <- obj$cvfit$cv.stats$cv.lrt
        a <- a + 1
      } else {
        cat("Permutation sample dropped... \n")
      }
    } else if (cvtype == "none") {
      obj <- tryCatch({cv.comb.box(x=x, times=perm.times, status=perm.status, varsign=varsign, selected=selected, initcutpts=initcutpts, K=1, arg=arg, probval=NULL, timeval=NULL, seed=NULL)}, error=function(w){NULL})
      if (is.list(obj)) {
        null.chisq[[a]] <- obj$cvfit$cv.stats$cv.lrt
        a <- a + 1
      } else {
        cat("Permutation sample dropped... \n")
      }
    } else {
      stop("Invalid CV type option \n")
    }
  }

  return(t(list2mat(null.chisq)))
}
##########################################################################################################################################




##########################################################################################################################################
#################
# Usage         :
################
#                   cv.ave.box (x, times, status,
#                               probval, timeval,
#                               varsign, selected, initcutpts,
#                               K, arg, seed)
#
################
# Description   :
################
#                   Return averaged K-fold cross-validated test boxes and quantities of interest
#
################
# Arguments     :
################
#
################
# Values        :
################
#
##########################################################################################################################################

cv.ave.box <- function(x, times, status,
                       probval, timeval,
                       varsign, selected, initcutpts,
                       K, arg, seed) {

  n <- nrow(x)
  p <- ncol(x)

  fold.obj <- cv.ave.fold(x=x, times=times, status=status,
                          probval=probval, timeval=timeval,
                          varsign=varsign, selected=selected, initcutpts=initcutpts,
                          K=K, arg=arg, seed=seed)
  trace.list <- fold.obj$trace
  steps.list <- fold.obj$steps
  boxcut.list <- fold.obj$boxcut
  drop <- fold.obj$drop

  # Cross-validated minimum length from all folds
  CV.Lm <- min(fold.obj$nsteps)

  # Get the variable traces
  # Variable traces are first stacked and truncated in a matrix where folds are by rows and steps by columns
  CV.trace <- list2mat(list=trace.list, trunc=CV.Lm)
  CV.trace <- t(CV.trace)
  dimnames(CV.trace) <- list(paste("step", 0:(CV.Lm-1), sep=""), 1:K)

  # Truncate the x-validated quantities from all folds to the same x-validated length
  for (k in 1:K) {
    boxcut.list[[k]] <- boxcut.list[[k]][1:CV.Lm,]
    steps.list[[k]] <- steps.list[[k]][1:CV.Lm]
  }

  # Compute the averaged box statistics for each step from all the folds
  # Each entry or row signifies a step
  CV.boxcut <- matrix(data=NA, nrow=CV.Lm, ncol=p, dimnames=list(paste("step", 0:(CV.Lm-1), sep=""), colnames(x)))
  CV.support <- rep(NA, CV.Lm)
  names(CV.support) <- paste("step", 0:(CV.Lm-1), sep="")
  CV.lhr <- rep(NA, CV.Lm)
  names(CV.lhr) <- paste("step", 0:(CV.Lm-1), sep="")
  CV.lrt <- rep(NA, CV.Lm)
  names(CV.lrt) <- paste("step", 0:(CV.Lm-1), sep="")
  CV.cer <- rep(NA, CV.Lm)
  names(CV.cer) <- paste("step", 0:(CV.Lm-1), sep="")
  CV.time.bar <- rep(NA, CV.Lm)
  names(CV.time.bar) <- paste("step", 0:(CV.Lm-1), sep="")
  CV.prob.bar <- rep(NA, CV.Lm)
  names(CV.prob.bar) <- paste("step", 0:(CV.Lm-1), sep="")
  CV.max.time.bar <- rep(NA, CV.Lm)
  names(CV.max.time.bar) <- paste("step", 0:(CV.Lm-1), sep="")
  CV.min.prob.bar <- rep(NA, CV.Lm)
  names(CV.min.prob.bar) <- paste("step", 0:(CV.Lm-1), sep="")
  for (l in 1:CV.Lm) {
    summincut <- matrix(NA, K, p)
    sumtime <- rep(NA, K)
    sumprob <- rep(NA, K)
    summaxtime <- rep(NA, K)
    summinprob <- rep(NA, K)
    sumlhr <- rep(NA, K)
    sumlrt <- rep(NA, K)
    sumci <- rep(NA, K)
    sumsupport <- rep(NA, K)
    for (k in 1:K) {
      outbounds <- steps.list[[k]][[l]]
      if (!is.null(outbounds)) {
        summincut[k,] <- boxcut.list[[k]][l,]
        sumlhr[k] <- steps.list[[k]][[l]][[1]]
        sumlrt[k] <- steps.list[[k]][[l]][[2]]
        sumci[k] <- steps.list[[k]][[l]][[3]]
        sumsupport[k] <- steps.list[[k]][[l]][[4]]
        sumtime[k] <- steps.list[[k]][[l]][[5]]
        sumprob[k] <- steps.list[[k]][[l]][[6]]
        summaxtime[k] <- steps.list[[k]][[l]][[7]]
        summinprob[k] <- steps.list[[k]][[l]][[8]]
      }
    }
    CV.boxcut[l, ] <- colMeans(summincut, na.rm=TRUE)
    CV.lhr[l] <- mean(sumlhr, na.rm=TRUE)
    CV.lrt[l] <- mean(sumlrt, na.rm=TRUE)
    CV.cer[l] <- mean(sumci, na.rm=TRUE)
    CV.support[l] <- mean(sumsupport, na.rm=TRUE)
    CV.time.bar[l] <- mean(sumtime, na.rm=TRUE)
    CV.prob.bar[l] <- mean(sumprob, na.rm=TRUE)
    CV.max.time.bar[l] <- mean(summaxtime, na.rm=TRUE)
    CV.min.prob.bar[l] <- mean(summinprob, na.rm=TRUE)
  }

  # Box peeling rules for each step
  CV.rules<- as.data.frame(matrix(data=NA, nrow=CV.Lm, ncol=p, dimnames=list(paste("step", 0:(CV.Lm-1), sep=""), colnames(x))))
  for (j in 1:p) {
    if (varsign[j] > 0) {
      ss <- ">="
    } else {
      ss <- "<="
    }
    CV.rules[, j] <- paste(colnames(x)[j], ss, format(x=CV.boxcut[, j], digits=3, nsmall=3), sep="")
  }

  # Get the box membership indicator vector of all observations for each step from all the folds
  # Based on the corresponding averaged box over the folds
  CV.boxind <- matrix(NA, nrow=CV.Lm, ncol=n)
  for (l in 1:CV.Lm) {
    boxcut <- CV.boxcut[l, ] * varsign
    x.cut <- t(t(x) * varsign)
    x.ind <- t(t(x.cut) >= boxcut)
    CV.boxind[l,] <- (rowMeans(x.ind) == 1)  # Set as TRUE which observations are inside the box boudaries for all axes directions
  }
  rownames(CV.boxind) <- paste("step", 0:(CV.Lm-1), sep="")
  colnames(CV.boxind) <- rownames(x)

  # Box vertices for each step
  x.range <- apply(X=x, MARGIN=2, FUN=range)
  CV.vertices <- vector(mode="list", length=CV.Lm)
  names(CV.vertices) <- paste("step", 0:(CV.Lm-1), sep="")
  for (l in 1:CV.Lm) {
    CV.vertices[[l]] <- matrix(data=NA, nrow=2, ncol=p, dimnames=list(c("LB","UB"), colnames(x)))
    for (j in 1:p) {
      CV.vertices[[l]][1,j] <- ifelse(test=(varsign[j] > 0), yes=max(x.range[1,j], CV.boxcut[l,j]), no=min(x.range[1,j], CV.boxcut[l,j]))
      CV.vertices[[l]][2,j] <- ifelse(test=(varsign[j] < 0), yes=min(x.range[2,j], CV.boxcut[l,j]), no=max(x.range[2,j], CV.boxcut[l,j]))
    }
  }

  # Applying the cross-validation criterion to the profiles
  # Cross-validated optimal length from all folds
  # By maximization of the LHR (between in and out box test samples)
  if (all(is.na(CV.lhr))) {
    CV.L.lhr <- NA
  } else {
    CV.L.lhr <- which.max(CV.lhr)
  }
  # By maximization of the LRT (between in and out box test samples)
  if (all(is.na(CV.lrt))) {
    CV.L.lrt <- NA
  } else {
    CV.L.lrt <- which.max(CV.lrt)
  }
  # By minimization of the CER (between predicted and observed inbox test samples survival times)
  if (all(is.na(CV.cer))) {
    CV.L.cer <- NA
  } else {
    CV.L.cer <- which.min(CV.cer)
  }

  # Box statistics for each step
  CV.stats <-  data.frame("cv.support"=CV.support,
                          "cv.lhr"=CV.lhr,
                          "cv.lrt"=CV.lrt,
                          "cv.cer"=CV.cer,
                          "cv.time.bar"=CV.time.bar,
                          "cv.prob.bar"=CV.prob.bar,
                          "cv.max.time.bar"=CV.max.time.bar,
                          "cv.min.prob.bar"=CV.min.prob.bar)
  rownames(CV.stats) <- paste("step", 0:(CV.Lm-1), sep="")

  # Create the return object 'CV.fit'
  CV.fit <- list("cv.nsteps.lhr"=CV.L.lhr,
                 "cv.nsteps.lrt"=CV.L.lrt,
                 "cv.nsteps.cer"=CV.L.cer,
                 "cv.maxsteps"=CV.Lm,
                 "cv.boxcut"=CV.boxcut,
                 "cv.rules"=CV.rules,
                 "cv.stats"=CV.stats,
                 "cv.trace"=CV.trace,
                 "cv.boxind"=CV.boxind,
                 "cv.vertices"=CV.vertices)

  return(list("x"=x, "times"=times, "status"=status,
              "cvfit"=CV.fit, "drop"=drop, "seed"=seed))
}
##########################################################################################################################################




##########################################################################################################################################
#################
# Usage         :
################
#                   cv.comb.box (x, times, status,
#                                probval, timeval,
#                                varsign, selected, initcutpts,
#                                K, arg, seed)
#
#
################
# Description   :
################
#                   Return combined K-fold cross-validated boxes and quantities of interest
#
################
# Arguments     :
################
#
################
# Values        :
################
#
##########################################################################################################################################

cv.comb.box <- function(x, times, status,
                        probval, timeval,
                        varsign, selected, initcutpts,
                        K, arg, seed) {
  n <- nrow(x)
  p <- ncol(x)

  fold.obj <- cv.comb.fold(x=x, times=times, status=status,
                           varsign=varsign, selected=selected, initcutpts=initcutpts,
                           K=K, arg=arg, seed=seed)
  ord <- fold.obj$key
  times.list <- fold.obj$cvtimes
  status.list <- fold.obj$cvstatus
  trace.list <- fold.obj$trace
  boxind.list <- fold.obj$boxind
  boxcut.list <- fold.obj$boxcut

  # Cross-validated minimum length from all folds
  CV.Lm <- min(fold.obj$nsteps)

  # Concatenates the observations of test times and status from all folds
  # Re-ordered by initial order of observations
  CV.times <- unlist(times.list)[ord]
  CV.status <- unlist(status.list)[ord]

  # Get the variable traces
  # Variable traces are first stacked and truncated in a matrix where folds are by rows and steps by columns
  CV.trace <- list2mat(list=trace.list, trunc=CV.Lm)
  CV.trace <- t(CV.trace)
  dimnames(CV.trace) <- list(paste("step", 0:(CV.Lm-1), sep=""), 1:K)

  # Get the combined box mincuts for each step from all the folds and truncate to the same x-validated length
  CV.boxcut <- matrix(data=NA, nrow=CV.Lm, ncol=p, dimnames=list(paste("step", 0:(CV.Lm-1), sep=""), colnames(x)))
  tmparray <- list2array(list=boxcut.list, trunc=CV.Lm)
  for (j in 1:p) {
    if (varsign[j] >= 0) {
      CV.boxcut[,j] <- apply(X=tmparray[,j,,drop=FALSE], MARGIN=1, FUN=max, na.rm=TRUE)
    } else {
      CV.boxcut[,j] <- apply(X=tmparray[,j,,drop=FALSE], MARGIN=1, FUN=min, na.rm=TRUE)
    }
  }

  # Box peeling rules for each step
  CV.rules<- as.data.frame(matrix(data=NA, nrow=CV.Lm, ncol=p, dimnames=list(paste("step", 0:(CV.Lm-1), sep=""), colnames(x))))
  for (j in 1:p) {
    if (varsign[j] > 0) {
      ss <- ">="
    } else {
      ss <- "<="
    }
    CV.rules[, j] <- paste(colnames(x)[j], ss, format(x=CV.boxcut[, j], digits=3, nsmall=3), sep="")
  }

  # Get the test box membership indicator vector of all observations for each step from all the folds
  # Based on the combined membership indicator vectors over the folds
  # Re-ordered by initial order of observations
  CV.boxind <- cbindlist(boxind.list, trunc=CV.Lm)[,ord]
  rownames(CV.boxind) <- paste("step", 0:(CV.Lm-1), sep="")
  colnames(CV.boxind) <- rownames(x)

  # Computation of box vertices for each step
  x.range <- apply(X=x, MARGIN=2, FUN=range)
  CV.vertices <- vector(mode="list", length=CV.Lm)
  names(CV.vertices) <- paste("step", 0:(CV.Lm-1), sep="")
  for (l in 1:CV.Lm) {
    CV.vertices[[l]] <- matrix(data=NA, nrow=2, ncol=p, dimnames=list(c("LB","UB"), colnames(x)))
    for (j in 1:p) {
      CV.vertices[[l]][1,j] <- ifelse(test=(varsign[j] > 0),
                                      yes=max(x.range[1,j], CV.boxcut[l,j]),
                                      no=min(x.range[1,j], CV.boxcut[l,j]))
      CV.vertices[[l]][2,j] <- ifelse(test=(varsign[j] < 0),
                                      yes=min(x.range[2,j], CV.boxcut[l,j]),
                                      no=max(x.range[2,j], CV.boxcut[l,j]))
    }
  }

  # Compute the combined test box statistics from all folds for all steps, each entry or row signifies a step
  CV.support <- rep(NA, CV.Lm)
  names(CV.support) <- paste("step", 0:(CV.Lm-1), sep="")
  CV.lhr <- rep(NA, CV.Lm)
  names(CV.lhr) <- paste("step", 0:(CV.Lm-1), sep="")
  CV.lrt <- rep(NA, CV.Lm)
  names(CV.lrt) <- paste("step", 0:(CV.Lm-1), sep="")
  CV.cer <- rep(NA, CV.Lm)
  names(CV.cer) <- paste("step", 0:(CV.Lm-1), sep="")
  CV.time.bar <- rep(NA, CV.Lm)
  names(CV.time.bar) <- paste("step", 0:(CV.Lm-1), sep="")
  CV.prob.bar <- rep(NA, CV.Lm)
  names(CV.prob.bar) <- paste("step", 0:(CV.Lm-1), sep="")
  CV.max.time.bar <- rep(NA, CV.Lm)
  names(CV.max.time.bar) <- paste("step", 0:(CV.Lm-1), sep="")
  CV.min.prob.bar <- rep(NA, CV.Lm)
  names(CV.min.prob.bar) <- paste("step", 0:(CV.Lm-1), sep="")
  timemat <- matrix(NA, nrow=CV.Lm, ncol=n)
  probmat <- matrix(NA, nrow=CV.Lm, ncol=n)
  ind.rem <- numeric(0)
  for (l in 1:CV.Lm) {
    boxind <- CV.boxind[l,]
    boxind1 <- 1*boxind
    if ((l == 1) && (sum(boxind, na.rm=TRUE) != 0)) {
      surv.fit <- survfit(Surv(CV.times[boxind], CV.status[boxind]) ~ 1)
      timemat[l, (1:length(surv.fit$time))] <- surv.fit$time
      probmat[l, (1:length(surv.fit$surv))] <- surv.fit$surv
      CV.lhr[l] <- 0
      CV.lrt[l] <- 0
      CV.cer[l] <- 1
      CV.support[l] <- 1
    } else if ((sum(boxind, na.rm=TRUE) != length(boxind[!is.na(boxind)])) && (sum(boxind, na.rm=TRUE) != 0)) {
      surv.fit <- survfit(Surv(CV.times[boxind], CV.status[boxind]) ~ 1)
      timemat[l, (1:length(surv.fit$time))] <- surv.fit$time
      probmat[l, (1:length(surv.fit$surv))] <- surv.fit$surv
      surv.formula <- (Surv(CV.times, CV.status) ~ 1 + boxind1)
      coxobj <- coxph(surv.formula, singular.ok=TRUE, iter.max=1)
      CV.lhr[l] <- coxobj$coef
      CV.lrt[l] <- survdiff(surv.formula, rho=0)$chisq
      predobj <- predict(object=coxobj, type="lp", reference="sample")
      CV.cer[l] <- rcorr.cens(x=predobj, S=Surv(CV.times, CV.status))['C Index']
      CV.support[l] <- mean(boxind, na.rm=TRUE)
    } else {
      timemat[l, ] <- NA
      probmat[l, ] <- NA
      CV.lhr[l] <- 0
      CV.lrt[l] <- 0
      CV.cer[l] <- 1
      CV.support[l] <- NA
      ind.rem <- c(ind.rem, l)
    }
  }
  if (length(ind.rem) != CV.Lm) {
    drop <- FALSE
    endobj <- endpoints (ind=ind.rem, timemat=timemat, probmat=probmat, timeval=timeval, probval=probval)
    time.bar <- endobj$time.bar
    prob.bar <- endobj$prob.bar
    max.time.bar <- endobj$max.time.bar
    min.prob.bar <- endobj$min.prob.bar
    for (l in 1:CV.Lm) {
      if (!(l %in% ind.rem)) {
        CV.time.bar[l] <- time.bar[l]
        CV.prob.bar[l] <- prob.bar[l]
        CV.max.time.bar[l] <-  max.time.bar[l]
        CV.min.prob.bar[l] <- min.prob.bar[l]
      } else {
        CV.time.bar[l] <- NA
        CV.prob.bar[l] <- NA
        CV.max.time.bar[l] <- NA
        CV.min.prob.bar[l] <- NA
      }
    }
  } else {
    cat("Dropped !\n", sep="")
    drop <- TRUE
    CV.time.bar <- rep(NA, CV.Lm)
    CV.prob.bar <- rep(NA, CV.Lm)
    CV.max.time.bar <- rep(NA, CV.Lm)
    CV.min.prob.bar <- rep(NA, CV.Lm)
  }

  # Applying the cross-validation criterion to the profiles
  # Cross-validated optimal length from all folds
  # By maximization of the LHR (between in and out box test samples)
  if (all(is.na(CV.lhr))) {
    CV.L.lhr <- NA
  } else {
    CV.L.lhr <- which.max(CV.lhr)
  }
  # By maximization of the LRT (between in and out box test samples)
  if (all(is.na(CV.lrt))) {
    CV.L.lrt <- NA
  } else {
    CV.L.lrt <- which.max(CV.lrt)
  }
  # By minimization of the CER (between predicted and observed inbox test samples survival times)
  if (all(is.na(CV.cer))) {
    CV.L.cer <- NA
  } else {
    CV.L.cer <- which.min(CV.cer)
  }

  # Box statistics for each step
  CV.stats <-  data.frame("cv.support"=CV.support,
                          "cv.lhr"=CV.lhr,
                          "cv.lrt"=CV.lrt,
                          "cv.cer"=CV.cer,
                          "cv.time.bar"=CV.time.bar,
                          "cv.prob.bar"=CV.prob.bar,
                          "cv.max.time.bar"=CV.max.time.bar,
                          "cv.min.prob.bar"=CV.min.prob.bar)
  rownames(CV.stats) <- paste("step", 0:(CV.Lm-1), sep="")

  # Create the return object 'CV.fit'
  CV.fit <- list("cv.nsteps.lhr"=CV.L.lhr,
                 "cv.nsteps.lrt"=CV.L.lrt,
                 "cv.nsteps.cer"=CV.L.cer,
                 "cv.maxsteps"=CV.Lm,
                 "cv.boxcut"=CV.boxcut,
                 "cv.rules"=CV.rules,
                 "cv.stats"=CV.stats,
                 "cv.trace"=CV.trace,
                 "cv.boxind"=CV.boxind,
                 "cv.vertices"=CV.vertices)

  return(list("x"=x, "times"=times, "status"=status,
              "cvfit"=CV.fit, "drop"=drop, "seed"=seed))
}
##########################################################################################################################################




##########################################################################################################################################
#################
# Usage         :
################
#                    cv.ave.fold (x, times, status,
#                                 probval, timeval,
#                                 varsign, selected, initcutpts,
#                                 K, arg, seed)
#
################
# Description   :
################
#                    Return averaged K-fold cross-validated quantities over the test sets
#
################
# Arguments     :
################
#
################
# Values        :
################
#
##########################################################################################################################################

cv.ave.fold <- function(x, times, status,
                        probval, timeval,
                        varsign, selected, initcutpts,
                        K, arg, seed) {

  drop <- FALSE
  folds <- cv.folds(n=nrow(x), K=K, seed=seed)
  steps <- vector(mode="list", length=K)
  boxcut <- vector(mode="list", length=K)
  trace <- vector(mode="list", length=K)
  nsteps <- numeric(K)

  for (k in 1:K) {
    cat("Overall fold : ", k, "\n", sep="")
    # Initialize training and test data
    if (K == 1) {
      traindata <- testdata <- x[folds$subsets[(folds$which == k)], ]
      traintime <- testtime <- times[folds$subsets[(folds$which == k)]]
      trainstatus <- teststatus <- status[folds$subsets[(folds$which == k)]]
    } else {
      traindata <- x[folds$subsets[(folds$which != k)], ]
      traintime <- times[folds$subsets[(folds$which != k)]]
      trainstatus <- status[folds$subsets[(folds$which != k)]]
      testdata <- x[folds$subsets[(folds$which == k)], ]
      testtime <- times[folds$subsets[(folds$which == k)]]
      teststatus <- status[folds$subsets[(folds$which == k)]]
    }
    peelobj <- cv.ave.peel(traindata=traindata, trainstatus=trainstatus, traintime=traintime,
                           testdata=testdata, teststatus=teststatus, testtime=testtime,
                           probval=probval, timeval=timeval,
                           varsign=varsign, selected=selected, initcutpts=initcutpts, K=K, arg=arg, seed=seed)

    # Store the test set data/results from each fold (Note: observations of times and status from each fold are ordered in the list)
    steps[[k]] <- peelobj$steps
    nsteps[[k]] <- peelobj$nsteps
    boxcut[[k]] <- peelobj$boxcut
    trace[[k]] <- peelobj$trace
    drop <- (drop || peelobj$drop)
  }

  return(list("nsteps"=nsteps, "steps"=steps, "boxcut"=boxcut, "trace"=trace, "drop"=drop))
}
##########################################################################################################################################




##########################################################################################################################################
#################
# Usage         :
################
#                    cv.comb.fold (x, times, status,
#                                  varsign, selected, initcutpts,
#                                  K, arg, seed)
#
################
# Description   :
################
#                    Return combined K-fold cross-validated quantities from a 'combined' test set
#
################
# Arguments     :
################
#
################
# Values        :
################
#
##########################################################################################################################################

cv.comb.fold <- function(x, times, status,
                         varsign, selected, initcutpts,
                         K, arg, seed) {

  folds <- cv.folds(n=nrow(x), K=K, seed=seed)
  cvtimes <- vector(mode="list", length=K)
  cvstatus <- vector(mode="list", length=K)
  boxind <- vector(mode="list", length=K)
  boxcut <- vector(mode="list", length=K)
  trace <- vector(mode="list", length=K)
  nsteps <- numeric(K)

  for (k in 1:K) {
    cat("Overall fold : ", k, "\n", sep="")
    if (K == 1) {
      traindata <- testdata <- x[folds$subsets[(folds$which == k)], ]
      traintime <- testtime <- times[folds$subsets[(folds$which == k)]]
      trainstatus <- teststatus <- status[folds$subsets[(folds$which == k)]]
    } else {
      traindata <- x[folds$subsets[(folds$which != k)], ]
      traintime <- times[folds$subsets[(folds$which != k)]]
      trainstatus <- status[folds$subsets[(folds$which != k)]]
      testdata <- x[folds$subsets[(folds$which == k)], ]
      testtime <- times[folds$subsets[(folds$which == k)]]
      teststatus <- status[folds$subsets[(folds$which == k)]]
    }
    peelobj <- cv.comb.peel(traindata=traindata, trainstatus=trainstatus, traintime=traintime,
                            testdata=testdata, teststatus=teststatus, testtime=testtime,
                            varsign=varsign, selected=selected, initcutpts=initcutpts, K=K, arg=arg, seed=seed)

    # Store the test set data/results from each fold
    # Note: the order of observations of times and status from each fold is kept in the list
    nsteps[k] <- peelobj$nsteps
    cvtimes[[k]] <- testtime
    cvstatus[[k]] <- teststatus
    boxind[[k]] <- peelobj$testindmat
    boxcut[[k]] <- peelobj$boxcut
    trace[[k]] <- peelobj$trace
  }

  return(list("nsteps"=nsteps, "key"=folds$key,
              "cvtimes"=cvtimes, "cvstatus"=cvstatus,
              "boxind"=boxind, "boxcut"=boxcut, "trace"=trace))
}
##########################################################################################################################################




##########################################################################################################################################
#################
# Usage         :
################
#                    cv.ave.peel (traindata, trainstatus, traintime,
#                                 testdata, teststatus, testtime,
#                                 probval, timeval,
#                                 varsign, selected, initcutpts,
#                                 K, arg, seed)
#
################
# Description   :
################
#
################
# Arguments     :
################
#
################
# Values        :
################
#
##########################################################################################################################################

cv.ave.peel <- function(traindata, trainstatus, traintime,
                        testdata, teststatus, testtime,
                        probval, timeval,
                        varsign, selected, initcutpts,
                        K, arg, seed) {

  # Training the model
  peelobj <- peel.box(traindata=traindata, traintime=traintime, trainstatus=trainstatus,
                      varsign=varsign, selected=selected, initcutpts=initcutpts,
                      arg=arg, seed=seed)
  nsteps <- peelobj$nsteps

  # Compute the box statistics for all steps, each entry or row signifies a step
  steps.list <- vector(mode="list", length=nsteps)
  timemat <- matrix(NA, nrow=nsteps, ncol=nrow(testdata))
  probmat <- matrix(NA, nrow=nsteps, ncol=nrow(testdata))
  ind.rem <- numeric(0)
  for (l in 1:nsteps) {
    # Extract the rule and sign as one vector
    boxcut <- peelobj$boxcut[l, ] * varsign
    test.cut <- t(t(testdata) * varsign)
    test.ind <- t(t(test.cut) >= boxcut)
    # Set as TRUE which observations are TRUE for all variables
    test.ind <- (rowMeans(test.ind) == 1)
    test.ind1 <- 1*test.ind
    if ((l == 1) && (sum(test.ind, na.rm=TRUE) != 0)) {
      lhr <- 0
      lrt <- 0
      cer <- 1
      support <- 1
      steps.list[[l]] <- c(lhr, lrt, cer, support)
      names(steps.list[[l]]) <- NULL
      surv.fit <- survfit(Surv(testtime[test.ind], teststatus[test.ind]) ~ 1)
      timemat[l, (1:length(surv.fit$time))] <- surv.fit$time
      probmat[l, (1:length(surv.fit$surv))] <- surv.fit$surv
    } else if ((sum(test.ind, na.rm=TRUE) != length(test.ind[!is.na(test.ind)])) && (sum(test.ind, na.rm=TRUE) != 0)) {
      surv.formula <- (Surv(testtime, teststatus) ~ 1 + test.ind1)
      coxobj <- coxph(surv.formula, singular.ok=TRUE, iter.max=1)
      lhr <- coxobj$coef
      lrt <- survdiff(surv.formula, rho=0)$chisq
      predobj <- predict(object=coxobj, type="lp", reference="sample")
      cer <- rcorr.cens(x=predobj, S=Surv(testtime, teststatus))['C Index']
      support <- mean(test.ind)
      steps.list[[l]] <- c(lhr, lrt, cer, support)
      names(steps.list[[l]]) <- NULL
      surv.fit <- survfit(Surv(testtime[test.ind], teststatus[test.ind]) ~ 1)
      timemat[l, (1:length(surv.fit$time))] <- surv.fit$time
      probmat[l, (1:length(surv.fit$surv))] <- surv.fit$surv
    } else {
      lhr <- 0
      lrt <- 0
      cer <- 1
      support <- NA
      steps.list[[l]] <- c(lhr, lrt, cer, support)
      names(steps.list[[l]]) <- NULL
      timemat[l, ] <- NA
      probmat[l, ] <- NA
      ind.rem <- c(ind.rem, l)
    }
  }
  if (length(ind.rem) != nsteps) {
    drop <- FALSE
    endobj <- endpoints (ind=ind.rem, timemat=timemat, probmat=probmat, timeval=timeval, probval=probval)
    time.bar <- endobj$time.bar
    prob.bar <- endobj$prob.bar
    max.time.bar <- endobj$max.time.bar
    min.prob.bar <- endobj$min.prob.bar
    for (l in 1:nsteps) {
      if (!(l %in% ind.rem)) {
        steps.list[[l]] <- c(steps.list[[l]], time.bar[l], prob.bar[l], max.time.bar[l], min.prob.bar[l])
      } else {
        steps.list[[l]] <- c(steps.list[[l]], NA, NA, NA, NA)
      }
    }
  } else {
    cat("Dropped !\n", sep="")
    drop <- TRUE
    for (l in 1:nsteps) {
      steps.list[[l]] <- rep(NA, 8)
    }
  }

  return(list("steps"=steps.list, "nsteps"=nsteps, "boxcut"=peelobj$boxcut, "trace"=peelobj$trace, "drop"=drop))
}
##########################################################################################################################################




##########################################################################################################################################
#################
# Usage         :
################
#                    cv.comb.peel (traindata, trainstatus, traintime,
#                                  testdata, teststatus, testtime,
#                                  varsign, selected, initcutpts,
#                                  K, arg, seed)
#
################
# Description   :
################
#
################
# Arguments     :
################
#
################
# Values        :
################
#
##########################################################################################################################################

cv.comb.peel <- function(traindata, trainstatus, traintime,
                         testdata, teststatus, testtime,
                         varsign, selected, initcutpts,
                         K, arg, seed) {
  # Training the model
  peelobj <- peel.box(traindata=traindata, traintime=traintime, trainstatus=trainstatus,
                      varsign=varsign, selected=selected, initcutpts=initcutpts,
                      arg=arg, seed=seed)
  nsteps <- peelobj$nsteps

  # Create matrix that will represent the index of the test data that is within the box (i.e. for each step)
  test.ind.mat <- matrix(NA, nrow=nsteps, ncol=nrow(testdata))
  for (l in 1:nsteps) {
    # Extract the rule and sign as one vector
    boxcut <- peelobj$boxcut[l, ] * varsign
    test.cut <- t(t(testdata) * varsign)
    test.ind <- t(t(test.cut) >= boxcut)
    # Set as TRUE which observations are TRUE for all variables
    test.ind.mat[l, ] <- (rowMeans(test.ind) == 1)
  }

  return(list("testindmat"=test.ind.mat, "nsteps"=nsteps, "boxcut"=peelobj$boxcut, "trace"=peelobj$trace))
}
##########################################################################################################################################





##########################################################################################################################################
#################
# Usage         :
################
#                    peel.box (traindata, traintime, trainstatus,
#                              varsign, selected, initcutpts,
#                              arg, seed)
#
################
# Description   :
################
#
################
# Arguments     :
################
#
################
# Values        :
################
#
##########################################################################################################################################

peel.box <- function(traindata, traintime, trainstatus,
                     varsign, selected, initcutpts,
                     arg, seed) {

  if (!is.null(seed))
    set.seed(seed)

  alpha <- NULL
  beta <- NULL
  minn <- NULL
  L <- NULL
  peelcriterion <- NULL
  eval(parse( text=unlist(strsplit(x=arg, split=",")) ))

  digits <- getOption("digits")

  # Ensures that the training data is a numeric matrix
  traindata <- as.matrix(traindata)
  mode(traindata) <- "numeric"

  # Constants
  n <- nrow(traindata)
  p <- ncol(traindata)
  beta <- max(minn/n, beta)                              # Minimal box support thresholded to 10 points
  ncut <- ceiling(log(beta) / log(1 - (1/n)))            # Maximal number of peeling steps
  pnz <- length(selected)                                   # Number of selected variables

  # Initializations of variable trace and box boundaries
  vartrace <- numeric(ncut)
  boxcut <- matrix(data=NA, nrow=ncut, ncol=p)

  # Initializations
  boxcutpts <- initcutpts
  boxmass <- 1
  boxes <- matrix(data=FALSE, nrow=n, ncol=p)            # Initial logical matrix of box membership indicator by dimension
  sel <- rep(TRUE, n)                                    # Initial logical vector of selected samples
  xsel <- traindata                                      # Initial selection of samples from training data
  varpeel <- (apply(traindata, 2, "var") > 10^(-digits)) # Initial selection of variables for peeling
  if (!(is.null(L))) {
    switch <- 1
  } else {
    L <- 1
    switch <- 0
  }
  l <- 0
  lhrlj <- matrix(NA, ncut, p)
  lrtlj <- matrix(NA, ncut, p)

  while ((boxmass >= beta) & (l*switch < L) & (sum(varpeel) > 0)) {
    l <- l + 1
    xsign <- t(t(xsel) * varsign)

    # Potential cutpts by dimension
    cutpts.sign <- updatecut(x=xsign, fract=alpha)
    cutpts <- cutpts.sign * varsign

    # Update box membership indicator by dimension
    boxes <- as.matrix(t((t(traindata) * varsign) >= as.vector(cutpts.sign)) & sel)

    vmd <- rep(NA, p)
    for (j in 1:pnz) {
      jnz <- selected[j]
      boxes1j <- 1 * boxes[,jnz]
      if ((sum(boxes1j) != length(boxes1j)) && (sum(boxes1j) != 0)) {
        # Rate of increase of LHR (between in and out box)
        if (peelcriterion == "hr") {
          lhrlj[l,jnz] <- coxph(Surv(traintime, trainstatus) ~ 1 + boxes1j, singular.ok=TRUE, iter.max=1)$coef
          if (l == 1) {
            vmd[jnz] <- (lhrlj[l,jnz] - 0) / (1 - mean(boxes1j))
          } else {
            vmd[jnz] <- (lhrlj[l,jnz] - lhrlj[l-1,jnz]) / (boxmass - mean(boxes1j))
          }
        # Rate of increase of LRT (between in and out box)
        } else if (peelcriterion == "lr") {
          lrtlj[l,jnz] <- survdiff(Surv(traintime, trainstatus) ~ 1 + boxes1j, rho=0)$chisq
          if (l == 1) {
            vmd[jnz] <- (lrtlj[l,jnz] - 0) / (1 - mean(boxes1j))
          } else {
            vmd[jnz] <- (lrtlj[l,jnz] - lrtlj[l-1,jnz]) / (boxmass - mean(boxes1j))
          }
        } else {
          stop("Invalid peeling criterion \n")
        }
      } else {
        varpeel[jnz] <- FALSE
      }
    }

    # If the last attempted peeling succeeded
    if (sum(varpeel) > 0) {
      # Maximizing the rate of increase of LHR or LRT (peeling criterion).
      # Only one variable (the first one in rank) is selected in case of ties
      varj <- which(vmd == max(vmd[(!is.nan(vmd)) & (!is.infinite(vmd))], na.rm=TRUE))[1]
      # Updating
      sel <- boxes[, varj, drop=TRUE]
      boxmass <- mean(1 * sel)
      xsel <- traindata[sel, ,drop=FALSE]
      varpeel <- (apply(xsel, 2, "var") > 10^(-digits))
      boxcutpts[varj] <- cutpts[varj]
      # Saving trained box quantities of interest for the current peeling step
      boxcut[l, ] <- boxcutpts
      vartrace[l] <- varj
    # Else exiting the loop and decrementing the last peeling step number since the last attempted peeling failed in that case
    } else {
      l <- l - 1
    }
  }

  if (l == 0) {
    # Taking the first step box covering all the data
    boxcut <- as.matrix(initcutpts)
    vartrace <- 0
  } else if (l >= 1) {
    # Prepending the first step box covering all the data
    boxcut <- rbind(initcutpts, boxcut[1:l, , drop=FALSE])
    vartrace <- c(0, vartrace[1:l])
  }

  rownames(boxcut) <- paste("step", 0:l, sep="")
  colnames(boxcut) <- colnames(traindata)
  names(vartrace) <- paste("step", 0:l, sep="")
  names(varsign) <- colnames(traindata)

  # Returning the final results, considering the starting point as step #0
  return(list("nsteps"=l+1,
              "boxcut"=boxcut,
              "trace"=vartrace))
}
##########################################################################################################################################




##########################################################################################################################################
#################
# Usage         :
################
#                    cv.folds (n, K, seed=NULL)
#
################
# Description   :
################
#                    Split n observations into K groups to be used for K-fold cross-validation.
#                    K should thereby be chosen such that all groups are of approximately equal size.
#
################
# Arguments     :
################
# n             :    Integer giving the number of observations to be split into groups.
# K	            :    Integer giving the number of groups into which the observations should be randomly split.
#                       Setting K also specifies the type of folds to be generated:
#                       Possible types are 'random cross-validation', 'leave-one-out cross-validation', or no cross-validation.
#                       K \in {2,...,n-1} yields random cross-validation.
#                       K = 1 yields no cross-validation.
#                       K = n yields leave-one-out cross-validation.
# seed          :    Integer seed for RNG of random splitting of the data.
#
################
# Values        :
################
#                    A list object with the following components:
# n	            :    Integer giving the number of observations.
# K	            :    Integer giving the number of folds.
# subsets	      :    Integer vector containing the permutation of the indices.
# which	        :    Integer vector giving the fold for each permuted observation.
# key           :    Integer vector containing the key of the indices to restore the original indices order
#                       from the permutation of the indices grouped and reordered by fold
# seed          :    Integer seed used for RNG of random splitting of the data.
#
##########################################################################################################################################

cv.folds <- function (n, K, seed=NULL) {

  if (!is.null(seed))
    set.seed(seed)

  n <- round(rep(n, length.out = 1))
  if (!isTRUE(n > 0))
    stop("'n' must be positive")
  K <- round(rep(K, length.out = 1))
  if (!isTRUE((K >= 1) && K <= n))
    stop(paste("'K' outside allowable range {1,...,", n, "} \n", sep=""))
  if (K == 1) {
    subs <- seq_len(n)
  } else if (K == n) {
    subs <- seq_len(n)
  } else {
    subs <- sample(n)
  }
  w <- rep(seq_len(K), length.out=n)
  ord <- numeric(0)
  for (k in 1:K) {
    ord <- c(ord, subs[(w == k)])
  }
  key <- pmatch(x=1:n, table=ord)
  folds <- list(n=n, K=K, subsets=subs, which=w, key=key, seed=seed)

  return(folds)
}
##########################################################################################################################################




##########################################################################################################################################
#################
# Usage         :
################
#                    endpoints (ind, timemat, probmat, timeval, probval)
#
################
# Description   :
################
#                    Return the maximum time value and the corresponding minimum survival probability
#                    for every box of the trajectory (box peeling sequence). Also return the time value
#                    and/or the corresponding survival probability depending on what is specified by the user.
#
################
# Arguments     :
################
#
################
# Values        :
################
#
##########################################################################################################################################

endpoints <- function(ind, timemat, probmat, timeval, probval) {

  N <- nrow(timemat) #N <- nrow(probmat)
  L <- N-length(ind)
  if (!(is.empty(ind))) {
    timemat <- timemat[-ind, , drop=FALSE]
    probmat <- probmat[-ind, , drop=FALSE]
  }
  min.prob.bar <- apply(probmat, 1, min, na.rm=TRUE)
  max.time.bar <- apply(timemat, 1, max, na.rm=TRUE)
  if (is.null(probval) && is.null(timeval)) {
    prob.bar <- rep(NA, L)
    time.bar <- rep(NA, L)
  } else if (!is.null(probval)) {
    prob.bar <- rep(probval, L)
    ind.probmat <- (probmat <= probval)
    ind.probmat[is.na(ind.probmat)] <- FALSE
    time.bar <- numeric(L)
    for (l in 1:L) {
      if (probval >= min.prob.bar[l]) {
        time.bar[l] <- min(timemat[l,which(ind.probmat[l,,drop=TRUE])])
      } else {
        time.bar[l] <- NA
      }
    }
  } else if (!is.null(timeval)) {
    time.bar <- rep(timeval, L)
    ind.timemat <- (timemat >= timeval)
    ind.timemat[is.na(ind.timemat)] <- FALSE
    prob.bar <- numeric(L)
    for (l in 1:L) {
      if (timeval <= max.time.bar[l]) {
        prob.bar[l] <- max(probmat[l,which(ind.timemat[l,,drop=TRUE])])
      } else {
        prob.bar[l] <- NA
      }
    }
  }

  return(list("time.bar"=time.bar,
              "prob.bar"=prob.bar,
              "max.time.bar"=max.time.bar,
              "min.prob.bar"=min.prob.bar))

}
##########################################################################################################################################




##########################################################################################################################################
#################
# Usage         :
################
#                    updatecut (x, fract)
#
################
# Description   :
################
#
################
# Arguments     :
################
#
################
# Values        :
################
#
##########################################################################################################################################

updatecut <- function(x, fract) {

  p <- dim(x)[2]
  cutpts <- apply(x, 2, "quantile", type=7, probs=fract)

  for (j in 1:p) {
    xunique <- sort(unique(x[, j]))
    if (length(xunique) == 1) {
      cutpts[j] <- min(xunique)
    } else {
      if (isTRUE(all.equal(as.single(cutpts[j]), as.single(min(xunique))))) {
        cutpts[j] <- xunique[2]
      }
    }
  }

  return(cutpts)
}
##########################################################################################################################################




##########################################################################################################################################
################
# Usage         :   lapply.array (X, trunc=NULL, sub=NULL, fill=NA, MARGIN=1:2, FUN, ...)
#
################
#
################
# Description   :
################
#                   Compute FUN element-wise on entries of a list of matrices (even of different row or column numbers)
#
#
#
################
# Arguments     :
################
#
################
# Values        :
################
#
##########################################################################################################################################

lapply.array <- function (X, trunc=NULL, sub=NULL, fill=NA, MARGIN=1:2, FUN, ...) {
  x <- list2array(list=X, sub=sub, trunc=trunc, fill=fill)
  return(apply(X=x, MARGIN=MARGIN, FUN=FUN, ...))
}
##########################################################################################################################################




##########################################################################################################################################
################
# Usage         :   lapply.mat (X, trunc=NULL, sub=NULL, fill=NA, MARGIN=2, FUN, ...)
#
################
#
################
# Description   :
################
#                   Compute FUN element-wise on entries of a list of vectors (even of different lengths)
#
#
#
################
# Arguments     :
################
#
################
# Values        :
################
#
##########################################################################################################################################

lapply.mat <- function (X, trunc=NULL, sub=NULL, fill=NA, MARGIN=2, FUN, ...) {
  x <- list2mat(list=X, sub=sub, trunc=trunc, fill=fill)
  return(apply(X=x, MARGIN=MARGIN, FUN=FUN, ...))
}
##########################################################################################################################################




##########################################################################################################################################
################
# Usage         :   list2array (list, trunc=NULL, sub=NULL, fill=NA)
#
################
#
################
# Description   :
################
#                   Internal function to bind a list of matrices
#                   (even of different row or column numbers)
#                   by third dimension of a single 3D array
#
################
# Arguments     :
################
#
################
# Values        :
################
#
##########################################################################################################################################

list2array <- function (list, trunc=NULL, sub=NULL, fill=NA) {
  if (!is.empty(list)) {
    if (is.null(sub)) {
      my.list <- list
    } else {
      L <- length(list)
      my.list <- vector(mode="list", length=L)
      for (i in 1:L) {
        my.list[[i]] <- list[[i]][[sub]]
      }
    }
    max.row <- max(sapply(my.list, nrow))
    max.col <- max(sapply(my.list, ncol))
    corrected.list <- lapply(my.list, function(x) {rbind(x, matrix(data=NA, nrow=max.row - nrow(x), ncol=ncol(x)))})
    corrected.list <- lapply(corrected.list, function(x) {cbind(x, matrix(data=fill, nrow=nrow(x), ncol=max.col - ncol(x)))})
    my.array <- array(data=fill, dim=c(nrow(corrected.list[[1]]), ncol(corrected.list[[1]]), length(corrected.list)))
    for(i in 1:length(corrected.list)) {
      my.array[,,i] <- corrected.list[[i]]
    }
    if (!is.null(trunc)) {
      if (trunc == "min") {
        trunc <- min(sapply(my.list, length))
      }
      my.array <- my.array[1:trunc,,,drop=FALSE]
    }
  } else {
    my.array <- array(data=fill, dim=c(0,0,0))
  }
  return(my.array)
}
##########################################################################################################################################




##########################################################################################################################################
################
# Usage         :   list2mat (list, trunc=NULL, sub=NULL, fill=NA)
#
################
#
################
# Description   :
################
#                   Internal function to bind a list of vectors
#                   (even of different length) by rows into a single matrix
#
################
# Arguments     :
################
#
################
# Values        :
################
#
##########################################################################################################################################

list2mat <- function (list, trunc=NULL, sub=NULL, fill=NA) {
  if (!is.empty(list)) {
    if (is.null(sub)) {
      my.list <- list
    } else {
      L <- length(list)
      my.list <- vector(mode="list", length=L)
      for (i in 1:L) {
        my.list[[i]] <- list[[i]][[sub]]
      }
    }
    max.len <- max(sapply(my.list, length))
    corrected.list <- lapply(my.list, function(x) {c(x, rep(fill, max.len - length(x)))})
    my.mat <- do.call(rbind, corrected.list)
    if (!is.null(trunc)) {
      if (trunc == "min") {
        trunc <- min(sapply(my.list, length))
      }
      my.mat <- my.mat[, 1:trunc, drop=FALSE]
    }
  } else {
    my.mat <- matrix(data=fill, nrow=0, ncol=0)
  }
  return(my.mat)
}
##########################################################################################################################################




##########################################################################################################################################
################
# Usage         :   cbindlist (list, trunc)
#
################
#
################
# Description   :
################
#                   Internal function to bind a list of matrices by columns
#                   (even of different number of rows) into a single matrix
#
################
# Arguments     :
################
#
################
# Values        :
################
#
##########################################################################################################################################

cbindlist <- function(list, trunc) {
  if (!is.empty(list)) {
    max.row <- max(sapply(list, nrow))
    corrected.list <- lapply(list, function(x) {rbind(x, matrix(data=NA, nrow=max.row - nrow(x), ncol=ncol(x)))})
    my.mat <- corrected.list[[1]]
    lcl <- length(corrected.list)
    if (lcl > 1) {
      for(i in 2:lcl){
        my.mat <- cbind(my.mat, corrected.list[[i]])
      }
    }
    if (missing(trunc)) {
      trunc <- max.row
    }
    my.mat <- my.mat[1:trunc,,drop=FALSE]
  } else {
    my.mat <- matrix(data=NA, nrow=0, ncol=0)
  }
  return(my.mat)
}
##########################################################################################################################################




##########################################################################################################################################
################
# Usage         :   is.empty(x)
################
#
################
# Description   :
################
#                   Internal function to represent the empty array, matrix, or vector of zero dimension or length.
#                   Often returned by expressions and functions whose value is undefined.
#                   It returns a logical: TRUE if its argument is empty and FALSE otherwise.
#
################
# Arguments     :
################
# x             :   Array, matrix or vector of any type
#
################
# Values        :
################
#               :   Logical. Returns TRUE if its argument is empty and FALSE otherwise.
#
##########################################################################################################################################

is.empty <- function(x) {
  if (is.vector(x)) {
    if((length(x) == 0) || (x == "")) {
      return(TRUE)
    } else {
      return(FALSE)
    }
  } else if (is.matrix(x) || is.data.frame(x)) {
    return( ((nrow(x) == 0) || (ncol(x) == 0)) )
  } else {
    return( ((length(x) == 0) || (x == "")) )
  }
}
##########################################################################################################################################




##########################################################################################################################################
################
# Usage         :   myround (x, digits = 0)
################
#
################
# Description   :
################
#                   Go to the nearest digit rounding
#                   Note that for rounding off a .5, the "go to the even digit" standard is NOT used here.
#
################
# Arguments     :
################
# x             :   A numeric vector
# digits        :   Integer indicating the number of decimal places (precision) to be used (default = 0).
#
################
# Values        :
################
# x             :   Rounded numeric vector
#
##########################################################################################################################################

myround <- function (x, digits = 0) {
    upround <- function (x, digits = 0) {
        return(ceiling(x*10^(digits))/10^digits)
    }
    dnround <- function (x, digits = 0) {
        return(floor(x*10^digits)/10^digits)
    }
    i <- (x - trunc(x) >= 0.5)
    x[i] <- upround(x[i], digits=digits)
    x[!i] <- dnround(x[!i], digits=digits)
    return(x)
}
##########################################################################################################################################

