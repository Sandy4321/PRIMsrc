##########################################################################################################################################
# PRIMsrc
##########################################################################################################################################

##########################################################################################################################################
# 1. END-USER SURVIVAL BUMP HUNTING FUNCTION
##########################################################################################################################################

##########################################################################################################################################
################
# Usage         :
################
#                   sbh(dataset, discr,
#                       B=10, K=5, A=1000, cpv=FALSE, cvtype="combined", cvcriterion="lrt",
#                       arg="beta=0.05,alpha=0.1,minn=10,L=NULL,peelcriterion=\"lr\"",
#                       probval=NULL, timeval=NULL,
#                       parallel=FALSE, conf=NULL, seed=NULL)
#
################
# Description   :
################
#                   Unique end-user main function for fitting a cross-validated survival bump hunting model.
#                   Returns cross-validated "PRSP" object, as generated by our Patient Recursive Survival Peeling or PRSP algorithm
#                   at each iteration of the peeling sequence (inner loop of the PRSP algorithm).
#
################
# Arguments     :
################
# dataset       :   Data.frame or numeric matrix of input dataset containing the observed survival and status indicator variables in the first two columns, respectively.
# discr         :   Logical vector describing what covariates are discrete. Defaults to logical(ncol(dataset)-2).
# B             :   Number of replications of the cross-validation procedure. Defaults to 10.
# K             :   Number of folds for the cross-validation procedure. Defaults to 5.
# A             :   Number of permutations for the computation of p-values. Defaults to 1000.
# cpv           :   Logical. Flag for computation of cross-validated p-values. Defaults to FALSE.
#                   If computation of cross-validated p-value is deired, then running with the parallelization option is
#                   strongly advised, as it may take a while otherwise.
# cvtype        :   Character vector describing the cross-validation technique in {"none", "averaged", "combined"}.
#                   Defaults to "combined".
# cvcriterion   :   Character vector describing the cross-validation optimization criterion in {"lhr", "lrt", "cer"}.
#                   Defaults to "lrt". Automatically set to NULL if cvtype="none".
# arg           :   Character vector describing the parameters to use:
#                     alpha = fraction to peel off at each step. Defaults to 0.1.
#                     beta = minimum support size resulting from the peeling sequence. Defaults to 0.05.
#                     minn = minimum number of observation in a box. Defaults to 10.
#                     L = fixed peeling length. Defaults to NULL.
#                     peelcriterion in {"hr", "lr"}. Defaults to "lr".
# probval       :   Survival probability at which we want to get the endpoint box survival time.
#                   Defaults to NULL.
# timeval       :   Survival time at which we want to get the endpoint box survival probability.
#                   Defaults to NULL.
# parallel      :   Logical. Is parallel computing to be performed? Optional, defaults to FALSE.
# conf          :   List of parameters for cluster configuration.
#                   Inputs for R package parallel function makeCluster() for cluster setup.
#                   Optional, defaults to NULL. See details for usage.
# seed          :   User seed to reproduce the results.
#
################
# Values        :
################
#               :   Object of class "PRSP" (Patient Recursive Survival Peeling), list containing the following fields:
#
# x             :   Numeric matrix of original covariates.
# times         :   Observed failure / survival times.
# status        :   Observed event indicator \in {1,0}.
# B             :   Number of replications used in the cross-validation procedure.
# K             :   Number of folds used for the cross-validation procedure.
# A             :   Number of permutations used for the computation of p-values.
# cpv           :   Returned flag of computation of cross-validated p-values.
# cvtype        :   Cross-validation technique used.
# cvcriterion   :   Cross-validation optimization criterion used.
# varsign       :   Numeric vector \in {-1,+1} of directions of peeling for all variables.
# selected      :   Numeric vector giving the selected variable by regularized (Elastic-Net) Cox-regression.
# arg           :   Character vector of parameters used.
# probval       :   Survival probability used.
# timeval       :   Survival time used.
# cvfit         :   List of 7 fiels of cross-validated estimates:
#                     "cv.maxsteps"=numeric scalar of maximal ceiled-mean of number of peeling steps over the replicates
#                     "cv.nsteps"=numeric scalar of optimal number of peeling steps according to the optimization criterion
#                     "cv.trace"=list of numeric matrix and numeric vector of variable usage traces or modal trace values at each step
#                     "cv.boxind"=logical matrix {TRUE, FALSE} of sample box membership indicator (columns) by peeling steps (rows)
#                     "cv.rules"=data.frame of decision rules on the variable (columns) by peeling steps (rows)
#                     "cv.stats"=numeric matrix of box quantities of interest (columns) by peeling steps (rows)
#                     "cv.pval"=numeric vector of cross-validated log-rank p-values of sepraration of survival distributions
# cvprofiles    :   List (B) of numeric vectors, one for each replicate, of cross-validated statistic
#                   used in the optimization criterion (setup by user)
#                   as  function of the number of peeling steps.
# plot          :   Returned flag for plotting results (TRUE if cross-validation successful)
# seed          :   User seed(s) used:
#                   Integer scalar of a single value, if parallelization is used.
#                   Integer vector of values, one for each replication, if parallelization is not used.
#
##########################################################################################################################################

sbh <- function(dataset, discr,
                B=10, K=5, A=1000, cpv=FALSE, cvtype="combined", cvcriterion="lrt",
                arg="beta=0.05,alpha=0.1,minn=10,L=NULL,peelcriterion=\"lr\"",
                probval=NULL, timeval=NULL,
                parallel=FALSE, conf=NULL, seed=NULL) {

  # Parsing and evaluating parameters
  alpha <- NULL
  beta <- NULL
  minn <- NULL
  L <- NULL
  peelcriterion <- NULL
  eval(parse( text=unlist(strsplit(x=arg, split=",")) ))
  digits <- getOption("digits")

  # Checks
  if (missing(dataset)) {
    stop("\nNo dataset provided !\n\n")
  } else {
    cat("\nSurvival dataset provided.\n\n")
    if (!(is.data.frame(dataset)))
      dataset <- as.data.frame(dataset)
    x <- as.matrix(dataset[ ,-c(1,2), drop=FALSE])
    times <- dataset$stime
    status <- dataset$status
    times[times <= 0] <- 10^(-digits)
    n <- nrow(x)
    p <- ncol(x)
    if (missing(discr))
      discr <- logical(p)
  }

  # Summary of user options
  if (cvtype != "none") {
    if (B > 1) {
      if (parallel) {
        cat("Requested parallel replicated ", K, "-fold cross-validation with ", conf$cpus*ceiling(B/conf$cpus), " replications \n", sep="")
      } else {
        cat("Requested replicated ", K, "-fold cross-validation with ", B, " replications \n", sep="")
      }
    } else {
      cat("Requested single ", K, "-fold cross-validation with no replications \n", sep="")
    }
    cat("Cross-validation technique: ", cvtype, "\n")
    cat("Cross-validation criterion: ", cvcriterion, "\n")
    cat("Cross-validated p-values:", cpv, "\n")
  } else {
    cat("No cross-validation requested \n")
  }
  cat("Peeling criterion: ", peelcriterion, "\n")
  cat("Parallelization:", parallel, "\n")
  cat("\n")

  # Variable selection by regularized Cox-regression
  cat("Variable selection by regularized Cox-regression ... \n")
  k <- 0
  while (k < 10) {
    if (is.null(seed)) {
      seed <- floor(runif(n=1, min=0, max=1) * 10^(min(digits,9)))
    } else {
      set.seed(seed)
    }
    cv.fit <- cv.glmnet(x=x, y=Surv(times, status), nfolds=max(3,K), family="cox", maxit=1e5)
    fit <- glmnet(x=x, y=Surv(times, status), family="cox", maxit=1e5)
    cv.coef <- as.numeric(coef(fit, s=cv.fit$lambda.min))
    selected <- which(cv.coef != 0)
    if (is.empty(selected)) {
      k <- k + 1
      seed <- floor(runif(n=1, min=0, max=1) * 10^(min(digits,9)))
      if (k == 10) {
        success <- FALSE
      }
    } else {
      k <- 10
      success <- TRUE
    }
  }

  if (!success) {

    cat("Could not select any variable from the regularized Cox-regression model after 10 successive trials. Exiting...\n", sep="")
    bool.plot <- FALSE
    varsign <- NULL
    selected <- NULL
    used <- NULL
    # Cross-validated minimum length from all replicates
    CV.maxsteps <- NULL
    # List of CV profiles
    CV.profiles <- NULL
    # Cross-validated optimal length from all replicates
    CV.nsteps <- NULL
    # Modal or majority vote trace value over the replicates
    CV.trace <- NULL
    # List of box boxcut and box peeling rules for each step
    CV.rules <- NULL
    # Box membership indicator vector of all observations for each step
    CV.boxind <- NULL
    # List of box statistics for each step
    CV.stats <- NULL
    # List of p-values for each step
    CV.pval <- NULL

  } else {

    # Selected variables
    names(selected) <- colnames(x)[selected]
    cat("Selected variables:\n")
    print(selected)

    # Directions of directed peeling by selected variable and initial box boundaries
    varsign <- sign(cv.coef)
    names(varsign) <- colnames(x)

    # Initial box boundaries
    initcutpts <- numeric(p)
    for(j in 1:p){
        if ((varsign[j] == 0) || (varsign[j] == 1)) {
            initcutpts[j] <- min(x[,j])
        } else if (varsign[j] == -1) {
            initcutpts[j] <- max(x[,j])
        } else {
            stop("There is no valid direction of peeling for variable: ", j, "\n", sep="")
        }
    }

    if (cvtype == "none") {
        cvcriterion <- NULL
    }

    cat("Fitting and cross-validating the Survival Bump Hunting model using the PRSP algorithm ... \n")
    if (!parallel) {
        if (is.null(seed)) {
            seed <- runif(n=B, min=1, max=2) * 10^(digits-2)
        } else {
            seed <- (0:(B-1)) + seed
        }
        CV.box.rep.obj <- cv.box.rep(x=x, times=times, status=status,
                                     B=B, K=K, arg=arg,
                                     cvtype=cvtype,
                                     probval=probval, timeval=timeval,
                                     varsign=varsign, selected=selected, initcutpts=initcutpts,
                                     parallel=parallel, seed=seed)
    } else {
        if (conf$type == "SOCK") {
            cl <- makeCluster(spec=conf$names,
                              type=conf$type,
                              homogeneous=conf$homo,
                              outfile=conf$outfile,
                              verbose=conf$verbose)
        } else {
            cl <- makeCluster(spec=conf$cpus,
                              type=conf$type,
                              homogeneous=conf$homo,
                              outfile=conf$outfile,
                              verbose=conf$verbose)
        }
        clusterSetRNGStream(cl=cl, iseed=seed)
        a <- ceiling(B/conf$cpus)
        B <- a*conf$cpus
        obj.cl <- clusterCall(cl=cl, fun=cv.box.rep,
                              x=x, times=times, status=status,
                              B=a, K=K, arg=arg,
                              cvtype=cvtype,
                              probval=probval, timeval=timeval,
                              varsign=varsign, selected=selected, initcutpts=initcutpts,
                              parallel=parallel, seed=NULL)
        stopCluster(cl)
        CV.box.rep.obj <- list("cv.maxsteps"=numeric(0),
                               "cv.nsteps.lhr"=numeric(0),
                               "cv.nsteps.lrt"=numeric(0),
                               "cv.nsteps.cer"=numeric(0),
                               "cv.trace"=vector(mode="list", length=B),
                               "cv.boxind"=vector(mode="list", length=B),
                               "cv.boxcut"=vector(mode="list", length=B),
                               "cv.support"=vector(mode="list", length=B),
                               "cv.lhr"=vector(mode="list", length=B),
                               "cv.lrt"=vector(mode="list", length=B),
                               "cv.cer"=vector(mode="list", length=B),
                               "cv.time.bar"=vector(mode="list", length=B),
                               "cv.prob.bar"=vector(mode="list", length=B),
                               "cv.max.time.bar"=vector(mode="list", length=B),
                               "cv.min.prob.bar"=vector(mode="list", length=B))
        for (b in 1:conf$cpus) {
            CV.box.rep.obj$cv.maxsteps <- c(CV.box.rep.obj$cv.maxsteps, obj.cl[[b]]$cv.maxsteps)
            CV.box.rep.obj$cv.nsteps.lhr <- c(CV.box.rep.obj$cv.nsteps.lhr, obj.cl[[b]]$cv.nsteps.lhr)
            CV.box.rep.obj$cv.nsteps.lrt <- c(CV.box.rep.obj$cv.nsteps.lrt, obj.cl[[b]]$cv.nsteps.lrt)
            CV.box.rep.obj$cv.nsteps.cer <- c(CV.box.rep.obj$cv.nsteps.cer, obj.cl[[b]]$cv.nsteps.cer)
            CV.box.rep.obj$cv.trace[((b-1)*a+1):(b*a)] <- obj.cl[[b]]$cv.trace
            CV.box.rep.obj$cv.boxind[((b-1)*a+1):(b*a)] <- obj.cl[[b]]$cv.boxind
            CV.box.rep.obj$cv.boxcut[((b-1)*a+1):(b*a)] <- obj.cl[[b]]$cv.boxcut
            CV.box.rep.obj$cv.support[((b-1)*a+1):(b*a)] <- obj.cl[[b]]$cv.support
            CV.box.rep.obj$cv.lhr[((b-1)*a+1):(b*a)] <- obj.cl[[b]]$cv.lhr
            CV.box.rep.obj$cv.lrt[((b-1)*a+1):(b*a)] <- obj.cl[[b]]$cv.lrt
            CV.box.rep.obj$cv.cer[((b-1)*a+1):(b*a)] <- obj.cl[[b]]$cv.cer
            CV.box.rep.obj$cv.time.bar[((b-1)*a+1):(b*a)] <- obj.cl[[b]]$cv.time.bar
            CV.box.rep.obj$cv.prob.bar[((b-1)*a+1):(b*a)] <- obj.cl[[b]]$cv.prob.bar
            CV.box.rep.obj$cv.max.time.bar[((b-1)*a+1):(b*a)] <- obj.cl[[b]]$cv.max.time.bar
            CV.box.rep.obj$cv.min.prob.bar[((b-1)*a+1):(b*a)] <- obj.cl[[b]]$cv.min.prob.bar
        }
        CV.box.rep.obj$success <- obj.cl[[1]]$success
    }

    # Collect the peeling statistics for each step from all the replicates
    CV.maxsteps <- CV.box.rep.obj$cv.maxsteps
    CV.nsteps.lhr <- CV.box.rep.obj$cv.nsteps.lhr
    CV.nsteps.lrt <- CV.box.rep.obj$cv.nsteps.lrt
    CV.nsteps.cer <- CV.box.rep.obj$cv.nsteps.cer
    CV.trace <- CV.box.rep.obj$cv.trace
    CV.boxind <- CV.box.rep.obj$cv.boxind
    CV.boxcut <- CV.box.rep.obj$cv.boxcut
    CV.support <- CV.box.rep.obj$cv.support
    CV.lhr <- CV.box.rep.obj$cv.lhr
    CV.lrt <- CV.box.rep.obj$cv.lrt
    CV.cer <- CV.box.rep.obj$cv.cer
    CV.time.bar <- CV.box.rep.obj$cv.time.bar
    CV.prob.bar <- CV.box.rep.obj$cv.prob.bar
    CV.max.time.bar <- CV.box.rep.obj$cv.max.time.bar
    CV.min.prob.bar <- CV.box.rep.obj$cv.min.prob.bar
    success <- CV.box.rep.obj$success

    if (!success) {

        cat("Failure! Could not find any bump in this dataset. Exiting... \n", sep="")
        bool.plot <- FALSE
        varsign <- NULL
        selected <- NULL
        used <- NULL
        # Cross-validated minimum length from all replicates
        CV.maxsteps <- NULL
        # List of CV profiles
        CV.profiles <- NULL
        # Cross-validated optimal length from all replicates
        CV.nsteps <- NULL
        # Modal or majority vote trace value over the replicates
        CV.trace <- NULL
        # List of box boxcut and box peeling rules for each step
        CV.rules <- NULL
        # Box membership indicator vector of all observations for each step
        CV.boxind <- NULL
        # List of box statistics for each step
        CV.stats <- NULL
        # List of p-values for each step
        CV.pval <- NULL

    } else {

        cat("Success! ", B, " (replicated) cross-validation(s) has(ve) completed \n", sep="")
        bool.plot <- TRUE

        # Cross-validated minimum length from all replicates
        CV.maxsteps <- ceiling(mean(CV.maxsteps))

        # List of CV profiles
        cat("Generating cross-validated profiles and optimal peeling length ...\n")
        if ((cvtype == "averaged") || (cvtype == "combined")) {
            CV.lhr.mat <- list2mat(list=CV.lhr, fill=0, trunc=CV.maxsteps)
            CV.lrt.mat <- list2mat(list=CV.lrt, fill=0, trunc=CV.maxsteps)
            CV.cer.mat <- list2mat(list=CV.cer, fill=1, trunc=CV.maxsteps)
        } else if (cvtype == "none") {
            CV.lhr.mat <- matrix(data=NA, nrow=B, ncol=CV.maxsteps)
            CV.lrt.mat <- matrix(data=NA, nrow=B, ncol=CV.maxsteps)
            CV.cer.mat <- matrix(data=NA, nrow=B, ncol=CV.maxsteps)
        } else {
            stop("Invalid CV type option \n")
        }
        CV.profiles <- list("lhr"=CV.lhr.mat, "lrt"=CV.lrt.mat, "cer"=CV.cer.mat)
        colnames(CV.profiles$lhr) <- paste("step", 0:(CV.maxsteps-1), sep="")
        colnames(CV.profiles$lrt) <- paste("step", 0:(CV.maxsteps-1), sep="")
        colnames(CV.profiles$cer) <- paste("step", 0:(CV.maxsteps-1), sep="")

        # List of CV mean profiles
        CV.mean.lhr <- apply(CV.profiles$lhr, 2, mean)
        CV.mean.lrt <- apply(CV.profiles$lrt, 2, mean)
        CV.mean.cer <- apply(CV.profiles$cer, 2, mean)
        CV.mean.profiles <- list("lhr"=CV.mean.lhr, "lrt"=CV.mean.lrt, "cer"=CV.mean.cer)

        # Cross-validated optimal peeling length from all replicates
        if (cvtype == "none") {
            CV.nsteps <- CV.maxsteps
        } else if ((cvtype == "averaged") || (cvtype == "combined")) {
            if (cvcriterion=="lhr") {
                CV.nsteps <- which.max(CV.mean.profiles$lhr)
            } else if (cvcriterion=="lrt") {
                CV.nsteps <- which.max(CV.mean.profiles$lrt)
            } else if (cvcriterion=="cer") {
                CV.nsteps <- which.min(CV.mean.profiles$cer)
            }
        } else {
            stop("Invalid CV type option \n")
        }

        # Variable traces for each step
        # Distribution of trace values over the replicates, or
        # Modal or majority vote trace value over the loops and replicates
        cat("Generating cross-validated variable traces ...\n")
        trace.dist <- lapply.array(X=CV.trace,
                                   trunc=CV.nsteps,
                                   FUN=function(x){if (any(is.na(x)))
                                                    return(NA)
                                                   else
                                                    return(as.numeric(names(which.max(table(x)))))
                                                  },
                                   MARGIN=c(1,3))
        dimnames(trace.dist) <- list(paste("step", 0:(CV.nsteps-1), sep=""), 1:B)
        trace.mode <- apply(X=trace.dist,
                            FUN=function(x){as.numeric(names(which.max(table(x, useNA="no"))))},
                            MARGIN=1)
        names(trace.mode) <- paste("step", 0:(CV.nsteps-1), sep="")
        CV.trace <- list("dist"=trace.dist, "mode"=trace.mode)

        # Variables used for peeling
        used <- sort(unique(as.numeric(CV.trace$dist[-1,,drop=FALSE])))
        names(used) <- colnames(x)[used]
        cat("Variables used for peeling:\n")
        print(used)

        # List of box rules for each step
        cat("Generating cross-validated box rules for each step ...\n")
        CV.boxcut.mu <- lapply.array(X=CV.boxcut, trunc=CV.nsteps, FUN=function(x){mean(x, na.rm=TRUE)}, MARGIN=1:2)
        if (any(as.logical(discr))) {
        CV.boxcut.mu[,which(as.logical(discr))] <- myround(CV.boxcut.mu[,which(as.logical(discr)),drop=FALSE], 0)
        }
        CV.boxcut.sd <- lapply.array(X=CV.boxcut, trunc=CV.nsteps, FUN=function(x){sd(x, na.rm=TRUE)}, MARGIN=1:2)
        rownames(CV.boxcut.mu) <- paste("step", 0:(CV.nsteps-1), sep="")
        rownames(CV.boxcut.sd) <- paste("step", 0:(CV.nsteps-1), sep="")
        colnames(CV.boxcut.mu) <- colnames(x)
        colnames(CV.boxcut.sd) <- colnames(x)
        CV.tmp <- as.data.frame(matrix(data=NA, nrow=CV.nsteps, ncol=p, dimnames=list(paste("step", 0:(CV.nsteps-1), sep=""), colnames(x))))
        for (j in 1:p) {
        if (varsign[j] > 0) {
            ss <- ">="
        } else {
            ss <- "<="
        }
        CV.tmp[, j] <- paste(paste(colnames(x)[j], ss, format(x=CV.boxcut.mu[, j], digits=3, nsmall=3), sep=""),
                             format(x=CV.boxcut.sd[, j], digits=3, nsmall=3), sep=" +/- ")
        }
        CV.rules <- list("mean"=CV.boxcut.mu, "sd"=CV.boxcut.sd, "frame"=CV.tmp)

        # Box membership indicator vector of all observations for each step
        # using the modal or majority vote value over the replicates
        cat("Generating cross-validated box memberships for each step ...\n")
        CV.boxind <- lapply.array(X=CV.boxind, trunc=CV.nsteps, FUN=function(x){mean(x, na.rm=TRUE) >= 0.5}, MARGIN=1:2)
        rownames(CV.boxind) <- paste("step", 0:(CV.nsteps-1), sep="")
        colnames(CV.boxind) <- rownames(x)

        # List of box statistics for each step
        cat("Generating cross-validated box statistics for each step ...\n")
        CV.support.mu <- lapply.mat(X=CV.support, FUN=function(x){mean(x, na.rm=TRUE)}, trunc=CV.nsteps)
        CV.support.sd <- lapply.mat(X=CV.support, FUN=function(x){sd(x, na.rm=TRUE)}, trunc=CV.nsteps)
        CV.lhr.mu <- lapply.mat(X=CV.lhr, FUN=function(x){mean(x, na.rm=TRUE)}, trunc=CV.nsteps)
        CV.lhr.sd <- lapply.mat(X=CV.lhr, FUN=function(x){sd(x, na.rm=TRUE)}, trunc=CV.nsteps)
        CV.lrt.mu <- lapply.mat(X=CV.lrt, FUN=function(x){mean(x, na.rm=TRUE)}, trunc=CV.nsteps)
        CV.lrt.sd <- lapply.mat(X=CV.lrt, FUN=function(x){sd(x, na.rm=TRUE)}, trunc=CV.nsteps)
        CV.cer.mu <- lapply.mat(X=CV.cer, FUN=function(x){mean(x, na.rm=TRUE)}, trunc=CV.nsteps)
        CV.cer.sd <- lapply.mat(X=CV.cer, FUN=function(x){sd(x, na.rm=TRUE)}, trunc=CV.nsteps)
        CV.time.bar.mu <- lapply.mat(X=CV.time.bar, FUN=function(x){mean(x, na.rm=TRUE)}, trunc=CV.nsteps)
        CV.time.bar.sd <- lapply.mat(X=CV.time.bar, FUN=function(x){sd(x, na.rm=TRUE)}, trunc=CV.nsteps)
        CV.prob.bar.mu <- lapply.mat(X=CV.prob.bar, FUN=function(x){mean(x, na.rm=TRUE)}, trunc=CV.nsteps)
        CV.prob.bar.sd <- lapply.mat(X=CV.prob.bar, FUN=function(x){sd(x, na.rm=TRUE)}, trunc=CV.nsteps)
        CV.max.time.bar.mu <- lapply.mat(X=CV.max.time.bar, FUN=function(x){mean(x, na.rm=TRUE)}, trunc=CV.nsteps)
        CV.max.time.bar.sd <- lapply.mat(X=CV.max.time.bar, FUN=function(x){sd(x, na.rm=TRUE)}, trunc=CV.nsteps)
        CV.min.prob.bar.mu <- lapply.mat(X=CV.min.prob.bar, FUN=function(x){mean(x, na.rm=TRUE)}, trunc=CV.nsteps)
        CV.min.prob.bar.sd <- lapply.mat(X=CV.min.prob.bar, FUN=function(x){sd(x, na.rm=TRUE)}, trunc=CV.nsteps)
        CV.stats.mu <- data.frame("cv.support"=CV.support.mu,
                                  "cv.lhr"=CV.lhr.mu,
                                  "cv.lrt"=CV.lrt.mu,
                                  "cv.cer"=CV.cer.mu,
                                  "cv.time.bar"=CV.time.bar.mu,
                                  "cv.prob.bar"=CV.prob.bar.mu,
                                  "cv.max.time.bar"=CV.max.time.bar.mu,
                                  "cv.min.prob.bar"=CV.min.prob.bar.mu)
        rownames(CV.stats.mu) <- paste("step", 0:(CV.nsteps-1), sep="")
        CV.stats.sd <- data.frame("cv.support"=CV.support.sd,
                                  "cv.lhr"=CV.lhr.sd,
                                  "cv.lrt"=CV.lrt.sd,
                                  "cv.cer"=CV.cer.sd,
                                  "cv.time.bar"=CV.time.bar.sd,
                                  "cv.prob.bar"=CV.prob.bar.sd,
                                  "cv.max.time.bar"=CV.max.time.bar.sd,
                                  "cv.min.prob.bar"=CV.min.prob.bar.sd)
        rownames(CV.stats.sd) <- paste("step", 0:(CV.nsteps-1), sep="")
        CV.stats <- list("mean"=CV.stats.mu, "sd"=CV.stats.sd)

        # Vector of p-values for each step
        if ((cpv) && (cvtype != "none")) {
            cat("Computation of cross-validated LRT p-values at all steps ... \n")
            arg <- paste("beta=", beta, ",alpha=", alpha, ",minn=", minn, ",L=", CV.nsteps-1, ",peelcriterion=\"", peelcriterion, "\"", sep="")
            CV.pval <- cv.pval(x=x, times=times, status=status,
                               cvtype=cvtype,
                               varsign=varsign, selected=selected, initcutpts=initcutpts,
                               A=A, K=K, arg=arg, obs.chisq=CV.stats$mean$cv.lrt,
                               parallel=parallel, conf=conf)
        } else {
            CV.pval <- NULL
        }
    }
  }

  # Create the return object 'CV.fit'
  CV.fit <- list("cv.maxsteps"=CV.maxsteps,
                 "cv.nsteps"=CV.nsteps,
                 "cv.trace"=CV.trace,
                 "cv.boxind"=CV.boxind,
                 "cv.rules"=CV.rules,
                 "cv.stats"=CV.stats,
                 "cv.pval"=CV.pval)
  cat("Finished!\n")

  return(structure(list("x"=x, "times"=times, "status"=status,
                        "B"=B, "K"=K, "A"=A, "cpv"=cpv, "arg"=arg,
                        "cvtype"=cvtype, "cvcriterion"=cvcriterion,
                        "varsign"=varsign, "selected"=selected, "used"=used,
                        "probval"=probval, "timeval"=timeval,
                        "cvfit"=CV.fit, "cvprofiles"=CV.profiles,
                        "plot"=bool.plot, "seed"=seed),
                   class = "PRSP"))
}
##########################################################################################################################################




##########################################################################################################################################
# 2. END-USER FUNCTIONS
##########################################################################################################################################

##########################################################################################################################################
################
#Usage         :
################
#                   PRIMsrc.news(...)
#
################
# Description   :
################
#                   Function to display the log file of updates of the PRIMsrc package.
#
################
# Arguments     :
################
# ...               Further arguments passed to or from other methods.
#
################
# Values        :
################
#                   None.
#
##########################################################################################################################################

PRIMsrc.news <- function(...) {
    newsfile <- file.path(system.file(package="PRIMsrc"), "NEWS")
    file.show(newsfile)
}
##########################################################################################################################################




##########################################################################################################################################
################
#Usage         :
################
#                   summary(object, ...)
#
################
# Description   :
################
#                   S3 generic summary function to display the main parameters of a "PRSP" object.
#
################
# Arguments     :
################
# object        :   Object of class "PRSP" as generated by the main function sbh().
# ...           :   Further generic arguments passed to the summary function.
#
################
# Values        :
################
#                   None.
#
##########################################################################################################################################

summary.PRSP <- function(object, ...) {
  if (object$cvtype != "none") {
    if (object$B > 1) {
      cat("PRSP object with replicated ", object$K, "-fold cross-validation with ", object$B, " replications \n", sep="")
    } else {
      cat("PRSP object with replicated ", object$K, "-fold cross-validation without replications \n", sep="")
    }
    cat("Cross-validation technique: ", object$cvtype, "\n")
    cat("Cross-validation criterion: ", object$cvcriterion, "\n")
    cat("Cross-validated p-values:", object$cpv, "\n")
  } else {
    cat("PRSP object without cross-validation \n", sep="")
    cat("Cross-validation technique: ", object$cvtype, "\n")
    cat("Cross-validation criterion: ", object$cvcriterion, "\n")
    cat("Cross-validated p-values:", object$cpv, "\n")
  }
}
##########################################################################################################################################




##########################################################################################################################################
################
#Usage         :
################
#                   predict(object, newdata, steps, na.action = na.omit, ...)
#
################
# Description   :
################
#                   S3 generic predict function to predict the box membership and box vertices on an independent set
#                   from a "PRSP" object trained by a SBH model.
#
################
# Arguments     :
################
# object        :   Object of class "PRSP" as generated by the main function sbh().
# newdata       :   An object containing the new input data: either a numeric matrix or numeric vector.
#                   A vector will be transformed to a (#sample x 1) matrix.
# steps         :   Integer vector. Vector of peeling steps at which to predict the box memberships and box vertices.
#                   Defaults to the last peeling step.
# na.action     :   A function to specify the action to be taken if NAs are found.
#                   The default action is na.omit, which leads to rejection of incomplete cases.
# ...           :   Further generic arguments passed to the predict function.
#
################
# Values        :
################
# boxind        :   Logical matrix {TRUE, FALSE} of predicted box membership indicator (columns) by peeling steps (rows).
#                   (TRUE = in-box, FALSE = out-of-box)
# vertices      :   List of numeric matrix of predicted box vertices: box lower and upper bounds (rows) by variable (columns).
#                   One entry for each peeling steps.
#
##########################################################################################################################################

predict.PRSP <- function (object, newdata, steps, na.action = na.omit, ...) {

  X <- as.matrix(newdata)
  X.names <- colnames(X)
  X.range <- apply(X=X, MARGIN=2, FUN=range)
  n <- nrow(X)
  p <- ncol(X)

  if (ncol(object$x) != p) {
    stop("Non-matching dimensions of newdata to PRSP object \n")
  }

  if (missing(steps) || is.null(steps))
    steps <- object$cvfit$cv.nsteps

  L <- length(steps)
  boxcut <- object$cvfit$cv.rules$mean[steps,,drop=FALSE]
  varsign <- object$varsign

  pred.boxind <- matrix(NA, nrow=L, ncol=n, dimnames=list(paste("step ", steps, sep=""), rownames(X)))
  for (l in 1:L) {
    boxcutsign <- boxcut[l, ] * varsign
    x.cut <- t(t(X) * varsign)
    x.ind <- t(t(x.cut) >= boxcutsign)
    pred.boxind[l,] <- (rowMeans(x.ind) == 1)  # Set as TRUE which observations are inside the box boundaries for all axes directions
  }

  pred.vertices <- vector(mode="list", length=L)
  names(pred.vertices) <- paste("step ", steps, sep="")
  for (i in 1:L) {
    pred.vertices[[i]] <- matrix(data=NA, nrow=2, ncol=p, dimnames=list(c("LB","UB"), X.names))
    for (j in 1:p) {
      pred.vertices[[i]][1,j] <- ifelse(test=(varsign[j] > 0),
                                        yes=max(X.range[1,j], boxcut[i,j]),
                                        no=min(X.range[1,j], boxcut[i,j]))
      pred.vertices[[i]][2,j] <- ifelse(test=(varsign[j] < 0),
                                        yes=min(X.range[2,j], boxcut[i,j]),
                                        no=max(X.range[2,j], boxcut[i,j]))
    }
  }

  return(list("boxind"=pred.boxind, "vertices"=pred.vertices))
}
##########################################################################################################################################




##########################################################################################################################################
# 3. END-USER FUNCTIONS FOR MODEL VALIDATION AND VISUALIZATION OF RESULTS
##########################################################################################################################################

##########################################################################################################################################
################
# Usage         :
################
#                    plot.profile(x,
#                                 main=NULL, xlab="Peeling Steps", ylab="Mean Profiles",
#                                 add.sd=TRUE, add.legend=TRUE, add.profiles=TRUE,
#                                 pch=20, col=1, lty=1, lwd=2, cex=2,
#                                 device=NULL, file="Profile Plot", path=getwd(),
#                                 horizontal=FALSE, width=8.5, height=5, ...) {
#
################
# Description   :
################
#                   Plotting function of cross-validated profiles of specific statistics LHR, LRT or CER
#                   as a function of the model tuning parameter that is the optimal number of peeling steps
#                   of the model at each iteration of the peeling sequence (inner loop of our PRSP algorithm).
#                   Used for visualizing and/or choosing purpose of the optimal K-fold cross-validated number of steps
#                   or select the optimal model.
#                   The optimization criterion is done either by:
#                      - maximization of the LHR (between in and out box test samples)
#                      - maximization of the LRT (between in and out box test samples)
#                      - minimization of the CER (between predicted and observed inbox test samples survival times)
#
################
# Arguments     :
################
#
################
# Values        :
################
#
##########################################################################################################################################

plot.profile.PRSP <- function(x,
                              main=NULL, xlab="Peeling Steps", ylab="Mean Profiles",
                              add.sd=TRUE, add.legend=TRUE, add.profiles=TRUE,
                              pch=20, col=1, lty=1, lwd=2, cex=2,
                              device=NULL, file="Profile Plot", path=getwd(),
                              horizontal=FALSE, width=8.5, height=5, ...) {

  if (x$plot) {
    if (is.null(x$cvcriterion)) {
      cat("No CV here, so no cross-validated tuning profile to plot!\n")
    } else {

      profileplot <- function(object, main, xlab, ylab,
                              add.sd, add.legend, add.profiles,
                              pch, col, lty, lwd, cex, ...) {

        if (object$cvcriterion == "lhr") {
          txt <- "LHR"
          profiles <- object$cvprofiles$lhr
          ylim <- range(0, profiles, na.rm=TRUE)
        } else if (object$cvcriterion == "lrt") {
          txt <- "LRT"
          profiles <- object$cvprofiles$lrt
          ylim <- range(0, profiles, na.rm=TRUE)
        } else if (object$cvcriterion == "cer") {
          txt <- "CER"
          profiles <- object$cvprofiles$cer
          ylim <- range(0, 1, profiles, na.rm=TRUE)
        } else {
          stop("Invalid CV criterion.\n")
        }
        if ((!is.null(main)) && (add.legend)) {
          par(mfrow=c(1, 1), oma=c(0, 0, 4, 0), mar=c(2.5, 2.5, 4.0, 1.5), mgp=c(1.5, 0.5, 0))
        } else if ((is.null(main)) && (!add.legend)) {
          par(mfrow=c(1, 1), oma=c(0, 0, 0, 0), mar=c(2.5, 2.5, 4.0, 1.5), mgp=c(1.5, 0.5, 0))
        } else {
          par(mfrow=c(1, 1), oma=c(0, 0, 1, 0), mar=c(2.5, 2.5, 4.0, 1.5), mgp=c(1.5, 0.5, 0))
        }
        Lm <- object$cvfit$cv.maxsteps
        mean.profile <- apply(profiles, 2, mean, na.rm=TRUE)
        se.profile <- apply(profiles, 2, sd, na.rm=TRUE)
        if (add.profiles) {
          matplot(t(profiles), axes=FALSE, type="b",
                  xlab="", ylab="", main="", ylim=ylim,
                  pch=pch, lty=1, lwd=lwd/4, cex=cex/4)
          par(new=TRUE)
        }
        plot(0:(Lm-1), mean.profile, axes=FALSE, type="b",
             xlab=xlab, ylab=paste(txt ," ", ylab, sep=""), main=NULL, ylim=ylim,
             pch=pch, col=col, lty=lty, lwd=lwd, cex=cex)
        axis(side=1, pos=min(ylim), at=0:(Lm-1), labels=0:(Lm-1), cex.axis=1, line=NA)
        axis(side=2, pos=0, at=pretty(ylim), cex.axis=1, line=NA)
        segments(x0=object$cvfit$cv.nsteps-1, y0=min(ylim), x1=object$cvfit$cv.nsteps-1, y1=mean.profile[object$cvfit$cv.nsteps], col=col, lty=2, lwd=lwd)
        if (add.sd) {
            arrows(0:(Lm-1), mean.profile, 0:(Lm-1), mean.profile - se.profile, length=0.1, angle=90, code=2, col=col, lwd=lwd)
            arrows(0:(Lm-1), mean.profile, 0:(Lm-1), mean.profile + se.profile, length=0.1, angle=90, code=2, col=col, lwd=lwd)
        }
        if (!is.null(main)) {
          if (add.legend) {
            title(main=main, xlab="", ylab="", line=3, outer=FALSE, xpd=TRUE)
            legend("top", xpd=TRUE, inset=-0.1, legend=c("Sample Mean", "Std. Error"), pch=pch, col=col, lty=lty, lwd=lwd, cex=0.6, pt.cex=cex/2)
          } else {
            title(main=main, xlab="", ylab="", line=1, outer=FALSE, xpd=TRUE)
          }
        } else {
          if (add.legend) {
            legend("top", xpd=TRUE, inset=0, legend=c("Sample Mean", "Std. Error"), pch=pch, col=col, lty=lty, lwd=lwd, cex=0.6, pt.cex=cex/2)
          }
        }
      }

      if (is.null(device)) {
        dev.new(width=width, height=height, title="Profile Plot", noRStudioGD = TRUE)
        profileplot(object=x, main=main, xlab=xlab, ylab=ylab,
                    add.sd=add.sd, add.legend=add.legend, add.profiles=add.profiles,
                    pch=pch, col=col, lty=lty, lwd=lwd, cex=cex)
      } else if (device == "PS") {
        path <- normalizePath(path=paste(path, "/", sep=""), winslash="\\", mustWork=FALSE)
        file <- paste(file, ".ps", sep="")
        cat("\nOUTPUT: \n")
        cat("Filename : ", file, "\n")
        cat("Directory: ", path, "\n")
        postscript(file=paste(path, file, sep=""), width=width, height=height, onefile=TRUE, horizontal=horizontal)
        profileplot(object=x, main=main, xlab=xlab, ylab=ylab,
                    add.sd=add.sd, add.legend=add.legend, add.profiles=add.profiles,
                    pch=pch, col=col, lty=lty, lwd=lwd, cex=cex)
        dev.off()
      } else if (device == "PDF") {
        path <- normalizePath(path=paste(path, "/", sep=""), winslash="\\", mustWork=FALSE)
        file <- paste(file, ".pdf", sep="")
        cat("\nOUTPUT: \n")
        cat("Filename : ", file, "\n")
        cat("Directory: ", path, "\n")
        pdf(file=paste(path, file, sep=""), width=width, height=height, onefile=TRUE, paper=ifelse(test=horizontal, yes="USr", no="US"))
        profileplot(object=x, main=main, xlab=xlab, ylab=ylab,
                    add.sd=add.sd, add.legend=add.legend, add.profiles=add.profiles,
                    pch=pch, col=col, lty=lty, lwd=lwd, cex=cex)
        dev.off()
      } else {
        stop("Currently allowed display devices are \"PS\" (Postscript) or \"PDF\" (Portable Document Format) \n")
      }
    }
  } else {
    cat("Either the regularized Cox regression modeling or the Survival Bump Hunting modeling failed for this dataset.\n
        So, there is nothing to plot here.\n")
  }
  invisible()
}

plot.profile <- function(x,
                         main=NULL, xlab="Peeling Steps", ylab="Mean Profiles",
                         add.sd=TRUE, add.legend=TRUE, add.profiles=TRUE,
                         pch=20, col=1, lty=1, lwd=2, cex=2,
                         device=NULL, file="Profile Plot", path=getwd(),
                         horizontal=FALSE, width=8.5, height=5, ...) {
    UseMethod(generic="plot.profile", object=x)
}
##########################################################################################################################################





##########################################################################################################################################
################
# Usage         :
################
#                    plot.scatter(x,
#                                 main=NULL,
#                                 proj=c(1,2), boxes=FALSE, steps,
#                                 add.legend=TRUE, pch=16, cex=0.7, col=1, box.col=1, box.lty=2, box.lwd=1,
#                                 device=NULL, file="Scatter Plot", path=getwd(),
#                                 horizontal=FALSE, width=5, height=5, ...)
#
################
# Description   :
################
#                   Plotting function for 2D visualization of the scatter of data and box vertices at a given peeling step.
#                   The plot is drawn with geometrically equal scales on the X and Y axes.
#
################
# Arguments     :
################
#
################
# Values        :
################
#
##########################################################################################################################################

plot.scatter.PRSP <- function(x,
                              main=NULL,
                              proj=c(1,2), splom=TRUE, boxes=FALSE, steps,
                              add.legend=TRUE, pch=16, cex=0.7, col=1, box.col=1, box.lty=2, box.lwd=1,
                              device=NULL, file="Scatter Plot", path=getwd(),
                              horizontal=FALSE, width=5, height=5, ...) {

  if (x$plot) {

    scatterplot <- function(object, main,
                            proj, splom, boxes, steps,
                            add.legend, pch, cex, col,
                            box.col, box.lty, box.lwd, ...) {

        if ((!is.null(main)) && (add.legend)) {
            par(mfrow=c(1, 1), oma=c(0, 0, 4, 0), mar=c(2.5, 2.5, 4.0, 1.5), mgp=c(1.5, 0.5, 0))
        } else if ((is.null(main)) && (!add.legend)) {
            par(mfrow=c(1, 1), oma=c(0, 0, 0, 0), mar=c(2.5, 2.5, 4.0, 1.5), mgp=c(1.5, 0.5, 0))
        } else {
            par(mfrow=c(1, 1), oma=c(0, 0, 1, 0), mar=c(2.5, 2.5, 4.0, 1.5), mgp=c(1.5, 0.5, 0))
        }

        X <- object$x[,proj]
        X.names <- colnames(X)

        if (missing(steps) || is.null(steps))
          steps <- object$cvfit$cv.nsteps

        L <- length(steps)
        if (length(box.col) < L) box.col <- rep(box.col, length=L)
        if (length(box.lty) < L) box.lty <- rep(box.lty, length=L)
        if (length(box.lwd) < L) box.lwd <- rep(box.lwd, length=L)
        eqscplot(x=X, col=1, type="p", main=NULL, xlab=X.names[1], ylab=X.names[2], ...)
        if (splom) {
            for (i in 1:L) {
                w <- object$cvfit$cv.boxind[steps[i],]
                points(x=object$x[w,proj], type="p", pch=pch, cex=cex, col=col[i], ...)
            }
        }
        if (boxes) {
            X.range <- apply(X=X, MARGIN=2, FUN=range)
            boxcut <- object$cvfit$cv.rules$mean[steps,proj,drop=FALSE]
            varsign <- object$varsign[proj]
            vertices <- vector(mode="list", length=L)
            for (i in 1:L) {
                vertices[[i]] <- matrix(data=NA, nrow=2, ncol=2, dimnames=list(c("LB","UB"), X.names))
                for (j in 1:2) {
                    vertices[[i]][1,j] <- ifelse(test=(varsign[j] > 0),
                                                 yes=max(X.range[1,j], boxcut[i,j]),
                                                 no=min(X.range[1,j], boxcut[i,j]))
                    vertices[[i]][2,j] <- ifelse(test=(varsign[j] < 0),
                                                 yes=min(X.range[2,j], boxcut[i,j]),
                                                 no=max(X.range[2,j], boxcut[i,j]))
                }
            }
            for (i in 1:L) {
                rect(vertices[[i]][1,1], vertices[[i]][1,2], vertices[[i]][2,1], vertices[[i]][2,2], border=box.col[i], col=NA, lty=box.lty[i], lwd=box.lwd[i])
            }
        }
        if (!is.null(main)) {
            title(main=main, xlab="", ylab="", line=1, outer=FALSE, xpd=TRUE)
        }
        if (add.legend) {
            legend("topleft", xpd=TRUE, inset=0.01, legend=paste("Steps: ", steps, sep=""), pch=pch, col=col, cex=cex)
        }
    }

    if (is.null(device)) {
        dev.new(width=width, height=height, title="Scatter Plot", noRStudioGD = TRUE)
        scatterplot(object=x, main=main,
                    proj=proj, splom=splom, boxes=boxes, steps=steps,
                    add.legend=add.legend, pch=pch, cex=cex, col=col,
                    box.col=box.col, box.lty=box.lty, box.lwd=box.lwd)
    } else if (device == "PS") {
        path <- normalizePath(path=paste(path, "/", sep=""), winslash="\\", mustWork=FALSE)
        file <- paste(file, ".ps", sep="")
        cat("\nOUTPUT: \n")
        cat("Filename : ", file, "\n")
        cat("Directory: ", path, "\n")
        postscript(file=paste(path, file, sep=""), width=width, height=height, onefile=TRUE, horizontal=horizontal)
        scatterplot(object=x, main=main,
                    proj=proj, splom=splom, boxes=boxes, steps=steps,
                    add.legend=add.legend, pch=pch, cex=cex, col=col,
                    box.col=box.col, box.lty=box.lty, box.lwd=box.lwd)
        dev.off()
    } else if (device == "PDF") {
        path <- normalizePath(path=paste(path, "/", sep=""), winslash="\\", mustWork=FALSE)
        file <- paste(file, ".pdf", sep="")
        cat("\nOUTPUT: \n")
        cat("Filename : ", file, "\n")
        cat("Directory: ", path, "\n")
        pdf(file=paste(path, file, sep=""), width=width, height=height, onefile=TRUE, paper=ifelse(test=horizontal, yes="USr", no="US"))
        scatterplot(object=x, main=main,
                    proj=proj, splom=splom, boxes=boxes, steps=steps,
                    add.legend=add.legend, pch=pch, cex=cex, col=col,
                    box.col=box.col, box.lty=box.lty, box.lwd=box.lwd)
        dev.off()
    } else {
        stop("Currently allowed display devices are \"PS\" (Postscript) or \"PDF\" (Portable Document Format) \n")
    }
  } else {
    cat("Either the regularized Cox regression modeling or the Survival Bump Hunting modeling failed for this dataset.\n
        So, there is nothing to plot here.\n")
  }
  invisible()
}

plot.scatter <- function(x,
                         main=NULL,
                         proj=c(1,2), splom=TRUE, boxes=FALSE, steps=x$cvfit$cv.nsteps,
                         add.legend=TRUE, pch=16, cex=0.7, col=1, box.col=2, box.lty=2, box.lwd=1,
                         device=NULL, file="Scatter Plot", path=getwd(),
                         horizontal=FALSE, width=5, height=5, ...) {
    UseMethod(generic="plot.scatter", object=x)
}
##########################################################################################################################################




##########################################################################################################################################
################
# Usage         :
################
#                    plot.boxtraj (x,
#                                  main=NULL, xlab="Box Mass", ylab="Variable Range",
#                                  col=2, lty=1, lwd=1,
#                                  cex=1, add.legend=FALSE, text.legend=NULL,
#                                  nr=NULL, nc=NULL,
#                                  device=NULL, file="Covariate Trajectory Plots", path=getwd())
#                                  horizontal=FALSE, width=8.5, height=8.5, ...)
#
################
# Description   :
################
#                   Plot the cross-validated peeling trajectories/profiles of covariates used for peeling
#                   and other statistical quantities of interest at each iteration of the peeling sequence
#                   (inner loop of our PRSP algorithm).
#
################
# Arguments     :
################
#
################
# Values        :
################
#
##########################################################################################################################################

plot.boxtraj.PRSP <- function(x,
                              main=NULL, xlab="Box Mass", ylab="Variable Range",
                              col=2, lty=1, lwd=1,
                              cex=1, add.legend=FALSE, text.legend=NULL,
                              nr=NULL, nc=NULL,
                              device=NULL, file="Covariate Trajectory Plots", path=getwd(),
                              horizontal=FALSE, width=8.5, height=11.5, ...) {

  if (x$plot) {

    boxtrajplot <- function(object,
                            main, xlab, ylab,
                            col, lty, lwd,
                            cex, add.legend, text.legend,
                            nr, nc, ...) {

        used <- object$used
        p <- length(used)
        varnames <- colnames(object$x)
        if (is.null(nc))
            nc <- 3
        if (is.null(nr)) {
            if (p %% nc == 0) {
                nr <- p%/%nc + 2
            } else {
                nr <- ((p+(1:nc))[which((p+(1:nc)) %% nc == 0)])%/%nc + 2
            }
        }
        if (!is.null(main)) {
            par(mfrow=c(nr, nc), oma=c(0, 0, 2, 0), mar=c(2.5, 2.5, 2.0, 1.5), mgp=c(1.5, 0.5, 0))
        } else {
            par(mfrow=c(nr, nc), oma=c(0, 0, 0, 0), mar=c(2.5, 2.5, 2.0, 1.5), mgp=c(1.5, 0.5, 0))
        }
        for (j in used) {
            plot(object$cvfit$cv.stats$mean$cv.support, 
                 object$cvfit$cv.rules$mean[,j], 
                 type='s', col=col, lty=lty,
                 main=paste(varnames[j], " variable trajectory", sep=""),
                 xlim=range(0,1), ylim=range(object$x[,j], na.rm=TRUE),
                 xlab=xlab, ylab=ylab, cex.main=cex)
            if (add.legend)
                legend("bottomleft", inset=0.01, legend=text.legend, cex=0.7)
        }
        par(mfg=c(nr-1, 1))
        plot(object$cvfit$cv.stats$mean$cv.support, 
             object$cvfit$cv.stats$mean$cv.support, 
             type='s', col=col, lty=lty, lwd=lwd,
             main="Box support trajectory",
             xlim=range(0,1), ylim=range(0, 1),
             xlab=xlab, ylab=expression(paste("Support (", beta, ")", sep="")), cex.main=cex)
        if (add.legend)
            legend("bottomright", inset=0.01, legend=text.legend, cex=0.7)
        par(mfg=c(nr-1, 2))
        plot(object$cvfit$cv.stats$mean$cv.support, 
             object$cvfit$cv.stats$mean$cv.max.time.bar, 
             type='s', col=col, lty=lty, lwd=lwd,
             main="MEFT trajectory",
             xlim=range(0,1), ylim=range(0, object$cvfit$cv.stats$mean$cv.max.time.bar, na.rm=TRUE),
             xlab=xlab, ylab="Time", cex.main=cex)
        if (add.legend)
            legend("bottomright", inset=0.01, legend=text.legend, cex=0.7)
        par(mfg=c(nr-1, 3))
        plot(object$cvfit$cv.stats$mean$cv.support, 
             object$cvfit$cv.stats$mean$cv.min.prob.bar, 
             type='s', col=col, lty=lty, lwd=lwd,
             main="MEFP trajectory",
             xlim=range(0,1), ylim=range(0,1),
             xlab=xlab, ylab="Probability", cex.main=cex)
        if (add.legend)
            legend("bottomright", inset=0.01, legend=text.legend, cex=0.7)
        par(mfg=c(nr, 1))
        plot(object$cvfit$cv.stats$mean$cv.support, 
             object$cvfit$cv.stats$mean$cv.lhr, 
             type='s', col=col, lty=lty, lwd=lwd,
             main="LHR trajectory", xlim=range(0,1), ylim=range(0, object$cvfit$cv.stats$mean$cv.lhr, na.rm=TRUE),
             xlab=xlab, ylab=expression(paste("Log-Hazard Ratio (", lambda,")", sep="")), cex.main=cex)
        if (add.legend)
            legend("top", inset=0.01, legend=text.legend, cex=0.7)
        par(mfg=c(nr, 2))
        plot(object$cvfit$cv.stats$mean$cv.support, 
             object$cvfit$cv.stats$mean$cv.lrt, 
             type='s', col=col, lty=lty, lwd=lwd,
             main="LRT trajectory",
             xlim=range(0,1), ylim=range(0, object$cvfit$cv.stats$mean$cv.lrt, na.rm=TRUE),
             xlab=xlab, ylab=expression(paste("Log-rank test (", chi^2 ,")", sep="")), cex.main=cex)
        if (add.legend)
            legend("top", inset=0.01, legend=text.legend, cex=0.7)
        par(mfg=c(nr, 3))
        plot(object$cvfit$cv.stats$mean$cv.support, 
             object$cvfit$cv.stats$mean$cv.cer, 
             type='s', col=col, lty=lty, lwd=lwd,
             main="CER trajectory",
             xlim=range(0,1), ylim=range(0, 1),
             xlab=xlab, ylab=expression(paste("1-C (", theta,")", sep="")), cex.main=cex)
        if (add.legend)
            legend("top", inset=0.01, legend=text.legend, cex=0.7)
        mtext(text=main, cex=1, side=3, outer=TRUE)
    }

    if (is.null(device)) {
        dev.new(width=width, height=height, title="Covariate Trajectory Plots", noRStudioGD = TRUE)
        boxtrajplot(object=x,
                    main=main, xlab=xlab, ylab=ylab,
                    col=col, lty=lty, lwd=lwd,
                    cex=cex, add.legend=add.legend, text.legend=text.legend,
                    nr=nr, nc=nc)
    } else if (device == "PS") {
        path <- normalizePath(path=paste(path, "/", sep=""), winslash="\\", mustWork=FALSE)
        file <- paste(file, ".ps", sep="")
        cat("\nOUTPUT: \n")
        cat("Filename : ", file, "\n")
        cat("Directory: ", path, "\n")
        postscript(file=paste(path, file, sep=""), width=width, height=height, onefile=TRUE, horizontal=horizontal)
        boxtrajplot(object=x,
                    main=main, xlab=xlab, ylab=ylab,
                    col=col, lty=lty, lwd=lwd,
                    cex=cex, add.legend=add.legend, text.legend=text.legend,
                    nr=nr, nc=nc)
        dev.off()
    } else if (device == "PDF") {
        path <- normalizePath(path=paste(path, "/", sep=""), winslash="\\", mustWork=FALSE)
        file <- paste(file, ".pdf", sep="")
        cat("\nOUTPUT: \n")
        cat("Filename : ", file, "\n")
        cat("Directory: ", path, "\n")
        pdf(file=paste(path, file, sep=""), width=width, height=height, onefile=TRUE, paper=ifelse(test=horizontal, yes="USr", no="US"))
        boxtrajplot(object=x,
                    main=main, xlab=xlab, ylab=ylab,
                    col=col, lty=lty, lwd=lwd,
                    cex=cex, add.legend=add.legend, text.legend=text.legend,
                    nr=nr, nc=nc)
        dev.off()
    } else {
        stop("Currently allowed display devices are \"PS\" (Postscript) or \"PDF\" (Portable Document Format) \n")
    }
  } else {
    cat("Either the regularized Cox regression modeling or the Survival Bump Hunting modeling failed for this dataset.\n
        So, there is nothing to plot here.\n")
  }
  invisible()
}

plot.boxtraj <- function(x,
                         main=NULL, xlab="Box Mass", ylab="Variable Range",
                         col=2, lty=1, lwd=1,
                         cex=1, add.legend=FALSE, text.legend=NULL,
                         nr=NULL, nc=NULL,
                         device=NULL, file="Covariate Trajectory Plots", path=getwd(),
                         horizontal=FALSE, width=8.5, height=8.5, ...) {
    UseMethod(generic="plot.boxtraj", object=x)
}
##########################################################################################################################################





##########################################################################################################################################
################
# Usage         :
################
#                    plot.boxtrace (x,
#                                   main=NULL, xlab="Box Mass", ylab="Variable Range",
#                                   center=FALSE, scale=FALSE,
#                                   col=rep(1,length(x$used)), lty=rep(1,length(x$used)), lwd=rep(1,length(x$used)),
#                                   cex=1, add.legend=FALSE, text.legend=NULL,
#                                   device=NULL, file="Covariate Trace Plots", path=getwd(),
#                                   horizontal=FALSE, width=8.5, height=8.5, ...)
#
################
# Description   :
################
#                    Plot the cross-validated modal trace curves of variable importance and variable usage
#                    of covariates used for peeling at each iteration of the peeling sequence
#                    (inner loop of our PRSP algorithm).
#
################
# Arguments     :
################
#
################
# Values        :
################
#
##########################################################################################################################################

plot.boxtrace.PRSP <- function(x,
                               main=NULL, xlab="Box Mass", ylab="Variable Range",
                               center=FALSE, scale=FALSE,
                               col=1:length(x$used), lty=rep(1,length(x$used)), lwd=rep(1,length(x$used)),
                               cex=1, add.legend=FALSE, text.legend=NULL,
                               device=NULL, file="Covariate Trace Plots", path=getwd(),
                               horizontal=FALSE, width=8.5, height=8.5, ...) {

  if (x$plot) {

    boxtraceplot <- function(object,
                             main, xlab, ylab,
                             center, scale,
                             col, lty, lwd,
                             cex, add.legend, text.legend, ...) {

        used <- object$used
        p <- length(used)
        varnames <- colnames(object$x)
        ticknames <- paste(varnames[used], " -", sep="")
        usedtrace <- pmatch(x=object$cvfit$cv.trace$mode[-1], table=used)
        boxcut.scaled <- scale(x=object$cvfit$cv.rules$mean[,used], center=center, scale=scale)
        if (!is.null(main)) {
            par(mfrow=c(2, 1), oma=c(0, 0, 2, 0), mar=c(2.5, 4.0, 2.0, 0.0), mgp=c(1.5, 0.5, 0))
        } else {
            par(mfrow=c(2, 1), oma=c(0, 0, 0, 0), mar=c(2.5, 4.0, 2.0, 0.0), mgp=c(1.5, 0.5, 0))
        }
        
        plot(x=object$cvfit$cv.stats$mean$cv.support, 
             y=boxcut.scaled[,1], type='n',
             xlim=range(0,1), ylim=range(boxcut.scaled),
             main="Variable Importance", xlab="", ylab="", cex.main=cex)
        for (j in 1:p) {
            lines(object$cvfit$cv.stats$mean$cv.support, boxcut.scaled[,j], type='l', col=col[j], lty=lty[j], lwd=lwd[j])
        }
        legend("top", inset=0.01, legend=varnames[used], col=col, lty=lty, lwd=lwd, cex=0.5*cex)
        if (center)
            abline(h=0, lty=2, col=1, lwd=0.3, xpd=FALSE)
        if (add.legend)
            legend("bottom", inset=0.01, legend=text.legend, cex=0.5*cex)
        mtext(text=xlab, cex=cex, side=1, line=1, outer=FALSE)
        mtext(text=ylab, cex=cex, side=2, line=2, outer=FALSE)
        
        plot(x=object$cvfit$cv.stats$mean$cv.support[-object$cvfit$cv.nsteps], 
             y=usedtrace,
             type='s', yaxt="n", col=1, lty=lty[1], lwd=lwd[1],
             xlim=range(0, 1), ylim=range(0, p),
             main="Variable Usage", xlab="", ylab="", cex.main=cex)
        par(mgp=c(1.5, 0, 0))
        axis(side=2, at=1:p, labels=ticknames, tick=FALSE, las=1, line=NA, cex.axis=0.5*cex, outer=FALSE)
        if (add.legend)
            legend("bottom", inset=0.01, legend=text.legend, cex=0.5*cex)
        mtext(text=xlab, cex=cex, side=1, line=1, outer=FALSE)
        mtext(text="Variables Used", cex=cex, side=2, line=3, outer=FALSE)
        mtext(text=main, cex=1, side=3, outer=TRUE)
    }
    
    if (is.null(device)) {
        dev.new(width=width, height=height, title="Covariate Trace Plots", noRStudioGD = TRUE)
        boxtraceplot(object=x,
                     main=main, xlab=xlab, ylab=ylab,
                     center=center, scale=scale,
                     col=col, lty=lty, lwd=lwd,
                     cex=cex, add.legend=add.legend, text.legend=text.legend)
    } else if (device == "PS") {
        path <- normalizePath(path=paste(path, "/", sep=""), winslash="\\", mustWork=FALSE)
        file <- paste(file, ".ps", sep="")
        cat("\nOUTPUT: \n")
        cat("Filename : ", file, "\n")
        cat("Directory: ", path, "\n")
        postscript(file=paste(path, file, sep=""), width=width, height=height, onefile=TRUE, horizontal=horizontal)
        boxtraceplot(object=x,
                     main=main, xlab=xlab, ylab=ylab,
                     center=center, scale=scale,
                     col=col, lty=lty, lwd=lwd,
                     cex=cex, add.legend=add.legend, text.legend=text.legend)
        dev.off()
    } else if (device == "PDF") {
        path <- normalizePath(path=paste(path, "/", sep=""), winslash="\\", mustWork=FALSE)
        file <- paste(file, ".pdf", sep="")
        cat("\nOUTPUT: \n")
        cat("Filename : ", file, "\n")
        cat("Directory: ", path, "\n")
        pdf(file=paste(path, file, sep=""), width=width, height=height, onefile=TRUE, paper=ifelse(test=horizontal, yes="USr", no="US"))
        boxtraceplot(object=x,
                     main=main, xlab=xlab, ylab=ylab,
                     center=center, scale=scale,
                     col=col, lty=lty, lwd=lwd,
                     cex=cex, add.legend=add.legend, text.legend=text.legend)
        dev.off()
    } else {
        stop("Currently allowed display devices are \"PS\" (Postscript) or \"PDF\" (Portable Document Format) \n")
    }
  } else {
    cat("Either the regularized Cox regression modeling or the Survival Bump Hunting modeling failed for this dataset.\n
        So, there is nothing to plot here.\n")
  }
  invisible()
}

plot.boxtrace <- function(x,
                          main=NULL, xlab="Box Mass", ylab="Variable Range",
                          center=FALSE, scale=FALSE,
                          col=1:length(x$used), lty=rep(1,length(x$used)), lwd=rep(1,length(x$used)),
                          cex=1, add.legend=FALSE, text.legend=NULL,
                          device=NULL, file="Covariate Trace Plots", path=getwd(),
                          horizontal=FALSE, width=8.5, height=8.5, ...) {
    UseMethod(generic="plot.boxtrace", object=x)
}
##########################################################################################################################################





##########################################################################################################################################
################
# Usage         :
################
#                    plot.boxkm (x,
#                                main=NULL, xlab="Time", ylab="Probability",
#                                precision, mark=3, col=2, cex=1,
#                                only.last=FALSE, nr=NULL, nc=NULL,
#                                device=NULL, file="Survival Plots", path=getwd(),
#                                horizontal=TRUE, width=11.5, height=8.5, ...)
#
################
# Description   :
################
#                   Plotting function of Kaplan-Meier survival curves.
#
################
# Arguments     :
################
#
################
# Values        :
################
#
##########################################################################################################################################

plot.boxkm.PRSP <- function(x,
                            main=NULL, xlab="Time", ylab="Probability",
                            precision, mark=3, col=2, cex=1,
                            only.last=FALSE, nr=NULL, nc=NULL,
                            device=NULL, file="Survival Plots", path=getwd(),
                            horizontal=TRUE, width=11.5, height=8.5, ...) {

  if (x$plot) {

    boxkmplot <- function(object,
                          main, xlab, ylab,
                          precision, mark, col, cex,
                          only.last, nr, nc, ...) {

        # set default values for missing parameters
        if (missing(precision)) {
            precision <- 1/object$A
        }
        used <- object$used
        p <- length(used)
        if (is.null(nc))
            nc <- 4
        if (is.null(nr)) {
            if (p %% nc == 0) {
                nr <- p%/%nc + 2
            } else {
                nr <- ((p+(1:nc))[which((p+(1:nc)) %% nc == 0)])%/%nc + 2
            }
        }
        times <- object$times
        status <- object$status
        L <- object$cvfit$cv.nsteps
        if (only.last) {
            steps <- L
        } else {
            steps <- 1:L
            if (!is.null(main)) {
                par(mfrow=c(nr, nc), oma=c(0, 0, 2, 0), mar=c(2.5, 2.5, 1.5, 1.5), mgp=c(1.5, 0.5, 0))
            } else {
                par(mfrow=c(nr, nc), oma=c(0, 0, 0, 0), mar=c(2.5, 2.5, 0.0, 1.5), mgp=c(1.5, 0.5, 0))
            }
        }
        for (l in steps) {
            boxind <- object$cvfit$cv.boxind[l,]
            ng <- length(unique(boxind[!is.na(boxind)]))
            if (ng == 1) {
                boxind <- 1*boxind
            } else {
                boxind <- 2 - 1*boxind
            }
            surv <- survfit(Surv(times, status) ~ 1 + boxind)
            if (l == 1) {
                plot(surv, main="", conf.int=TRUE, mark.time=FALSE, mark=NA, lty=2, lwd=0.5, col=col, cex=cex, xlab=xlab, ylab=ylab, ...)
                par(new=TRUE)
                plot(surv, main="", conf.int=FALSE, mark.time=TRUE, mark=mark, lty=1, lwd=1, col=col, cex=cex, xlab=xlab, ylab=ylab, ...)
            } else {
                plot(surv, main="", conf.int=TRUE, mark.time=FALSE, mark=NA, lty=c(2,2), lwd=c(0.5,0.5), col=c(col,1), cex=cex, xlab=xlab, ylab=ylab, ...)
                par(new=TRUE)
                plot(surv, main="", conf.int=FALSE, mark.time=TRUE, mark=mark, lty=c(1,1), lwd=c(1,1), col=c(col,1), cex=cex, xlab=xlab, ylab=ylab, ...)
            }
            legend("topright", inset=0.01, legend=c("outbox", "inbox"), lty=c(1,1), lwd=c(1,1), col=c(1,2), cex=0.9*cex)
            if (object$cpv) {
                if (object$cvfit$cv.pval[l] <= precision) {
                    legend("bottom", inset=0.11, col="black", cex=0.9*cex, bty="n",
                           legend=bquote(italic(p) <= .(precision)))
                } else {
                    legend("bottom", inset=0.11, col="black", cex=0.9*cex, bty="n",
                           legend=bquote(italic(p) == .(format(x=object$cvfit$cv.pval[l], scientific=FALSE, digits=4, nsmall=4))))
                }
            }
            legend("bottom", inset=0.01, col="black", cex=0.9*cex, bty="n",
                   legend=substitute(group("", list(paste(italic(LHR) == x, sep="")), ""), list(x=format(x=object$cvfit$cv.stats$mean$cv.lhr[l], digits=3, nsmall=3))))
            legend("bottom", inset=0.06, col="black", cex=0.9*cex, bty="n",
                   legend=substitute(group("", list(paste(italic(LRT) == x, sep="")), ""), list(x=format(x=object$cvfit$cv.stats$mean$cv.lrt[l], digits=3, nsmall=3))))
            legend("bottom", inset=0.16, legend=paste("Step ", l-1, sep=""), col=1, cex=0.9*cex, bty="n")
        }
        if (only.last) {
            if (!is.null(main)) {
                mtext(text=main, cex=cex, side=3, line=1, outer=FALSE)
            }
        } else {
            if (!is.null(main)) {
                mtext(text=main, cex=cex, side=3, outer=TRUE)
            }
        }
    }

    if (is.null(device)) {
        dev.new(width=width, height=height, title="Survival Plots", noRStudioGD = TRUE)
        boxkmplot(object=x,
                  main=main, xlab=xlab, ylab=ylab,
                  precision=precision, mark=mark, col=col, cex=cex,
                  only.last=only.last, nr=nr, nc=nc)
    } else if (device == "PS") {
        path <- normalizePath(path=paste(path, "/", sep=""), winslash="\\", mustWork=FALSE)
        file <- paste(file, ".ps", sep="")
        cat("\nOUTPUT: \n")
        cat("Filename : ", file, "\n")
        cat("Directory: ", path, "\n")
        postscript(file=paste(path, file, sep=""), width=width, height=height, onefile=TRUE, horizontal=horizontal)
        boxkmplot(object=x,
                  main=main, xlab=xlab, ylab=ylab,
                  precision=precision, mark=mark, col=col, cex=cex,
                  only.last=only.last, nr=nr, nc=nc)
        dev.off()
    } else if (device == "PDF") {
        path <- normalizePath(path=paste(path, "/", sep=""), winslash="\\", mustWork=FALSE)
        file <- paste(file, ".pdf", sep="")
        cat("\nOUTPUT: \n")
        cat("Filename : ", file, "\n")
        cat("Directory: ", path, "\n")
        pdf(file=paste(path, file, sep=""), width=width, height=height, onefile=TRUE, paper=ifelse(test=horizontal, yes="USr", no="US"))
        boxkmplot(object=x,
                  main=main, xlab=xlab, ylab=ylab,
                  precision=precision, mark=mark, col=col, cex=cex,
                  only.last=only.last, nr=nr, nc=nc)
        dev.off()
    } else {
        stop("Currently allowed display devices are \"PS\" (Postscript) or \"PDF\" (Portable Document Format) \n")
    }
  } else {
    cat("Either the regularized Cox regression modeling or the Survival Bump Hunting modeling failed for this dataset.\n
        So, there is nothing to plot here.\n")
  }
  invisible()
}

plot.boxkm <- function(x,
                       main=NULL, xlab="Time", ylab="Probability",
                       precision, mark=3, col=2, cex=1,
                       only.last=FALSE, nr=NULL, nc=NULL,
                       device=NULL, file="Survival Plots", path=getwd(),
                       horizontal=TRUE, width=11.5, height=8.5, ...) {
    UseMethod(generic="plot.boxkm", object=x)
}
##########################################################################################################################################


